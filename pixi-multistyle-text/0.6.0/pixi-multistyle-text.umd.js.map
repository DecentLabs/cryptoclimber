{"version":3,"file":"pixi-multistyle-text.umd.js","sources":["../src/pixi-multistyle-text.ts"],"sourcesContent":["/// <reference types=\"pixi.js\" />\n\n\"use strict\";\n\nexport interface ExtendedTextStyle extends PIXI.TextStyleOptions {\n\tvalign?: \"top\" | \"middle\" | \"bottom\" | \"baseline\" | number;\n\tdebug?: boolean;\n}\n\nexport interface TextStyleSet {\n\t[key: string]: ExtendedTextStyle;\n}\n\ninterface FontProperties {\n\tascent: number;\n\tdescent: number;\n\tfontSize: number;\n}\n\ninterface TextData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\twidth: number;\n\theight: number;\n\tfontProperties: FontProperties;\n\ttag: TagData;\n}\n\ninterface TextDrawingData {\n\ttext: string;\n\tstyle: ExtendedTextStyle;\n\tx: number;\n\ty: number;\n\twidth: number;\n\tascent: number;\n\tdescent: number;\n\ttag: TagData;\n}\n\nexport interface MstDebugOptions {\n\tspans: {\n\t\tenabled?: boolean;\n\t\tbaseline?: string;\n\t\ttop?: string;\n\t\tbottom?: string;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t};\n\tobjects: {\n\t\tenabled?: boolean;\n\t\tbounding?: string;\n\t\ttext?: boolean;\n\t}\n}\n\nexport interface TagData {\n\tname: string;\n\tproperties: { [key: string]: string };\n}\n\nexport interface MstInteractionEvent extends PIXI.interaction.InteractionEvent {\n\ttargetTag: TagData;\n}\n\nconst INTERACTION_EVENTS = [\n\t\"pointerover\",\n\t\"pointerenter\",\n\t\"pointerdown\",\n\t\"pointermove\",\n\t\"pointerup\",\n\t\"pointercancel\",\n\t\"pointerout\",\n\t\"pointerleave\",\n\t\"gotpointercapture\",\n\t\"lostpointercapture\",\n\t\"mouseover\",\n\t\"mouseenter\",\n\t\"mousedown\",\n\t\"mousemove\",\n\t\"mouseup\",\n\t\"mousecancel\",\n\t\"mouseout\",\n\t\"mouseleave\",\n\t\"touchover\",\n\t\"touchenter\",\n\t\"touchdown\",\n\t\"touchmove\",\n\t\"touchup\",\n\t\"touchcancel\",\n\t\"touchout\",\n\t\"touchleave\"\n];\n\nexport default class MultiStyleText extends PIXI.Text {\n\tprivate static DEFAULT_TAG_STYLE: ExtendedTextStyle = {\n\t\talign: \"left\",\n\t\tbreakWords: false,\n\t\t// debug intentionally not included\n\t\tdropShadow: false,\n\t\tdropShadowAngle: Math.PI / 6,\n\t\tdropShadowBlur: 0,\n\t\tdropShadowColor: \"#000000\",\n\t\tdropShadowDistance: 5,\n\t\tfill: \"black\",\n\t\tfillGradientType: PIXI.TEXT_GRADIENT.LINEAR_VERTICAL,\n\t\tfontFamily: \"Arial\",\n\t\tfontSize: 26,\n\t\tfontStyle: \"normal\",\n\t\tfontVariant: \"normal\",\n\t\tfontWeight: \"normal\",\n\t\tletterSpacing: 0,\n\t\tlineHeight: 0,\n\t\tlineJoin: \"miter\",\n\t\tmiterLimit: 10,\n\t\tpadding: 0,\n\t\tstroke: \"black\",\n\t\tstrokeThickness: 0,\n\t\ttextBaseline: \"alphabetic\",\n\t\tvalign: \"baseline\",\n\t\twordWrap: false,\n\t\twordWrapWidth: 100\n\t};\n\n\tpublic static debugOptions: MstDebugOptions = {\n\t\tspans: {\n\t\t\tenabled: false,\n\t\t\tbaseline: \"#44BB44\",\n\t\t\ttop: \"#BB4444\",\n\t\t\tbottom: \"#4444BB\",\n\t\t\tbounding: \"rgba(255, 255, 255, 0.1)\",\n\t\t\ttext: true\n\t\t},\n\t\tobjects: {\n\t\t\tenabled: false,\n\t\t\tbounding: \"rgba(255, 255, 255, 0.05)\",\n\t\t\ttext: true\n\t\t}\n\t};\n\n\tprivate textStyles: TextStyleSet;\n\n\tprivate hitboxes: { tag: TagData, hitbox: PIXI.Rectangle }[];\n\n\tconstructor(text: string, styles: TextStyleSet) {\n\t\tsuper(text);\n\n\t\tthis.styles = styles;\n\n\t\tINTERACTION_EVENTS.forEach((event) => {\n\t\t\tthis.on(event, (e: PIXI.interaction.InteractionEvent) => this.handleInteraction(e));\n\t\t});\n\t}\n\n\tprivate handleInteraction(e: PIXI.interaction.InteractionEvent) {\n\t\tlet ev = e as MstInteractionEvent;\n\n\t\tlet localPoint = e.data.getLocalPosition(this);\n\t\tlet targetTag = this.hitboxes.reduce((prev, hitbox) => prev !== undefined ? prev : (hitbox.hitbox.contains(localPoint.x, localPoint.y) ? hitbox : undefined), undefined);\n\t\tev.targetTag = targetTag === undefined ? undefined : targetTag.tag;\n\t}\n\n\tpublic set styles(styles: TextStyleSet) {\n\t\tthis.textStyles = {};\n\n\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\n\t\tfor (let style in styles) {\n\t\t\tif (style === \"default\") {\n\t\t\t\tthis.assign(this.textStyles[\"default\"], styles[style]);\n\t\t\t} else {\n\t\t\t\tthis.textStyles[style] = this.assign({}, styles[style]);\n\t\t\t}\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic setTagStyle(tag: string, style: ExtendedTextStyle): void {\n\t\tif (tag in this.textStyles) {\n\t\t\tthis.assign(this.textStyles[tag], style);\n\t\t} else {\n\t\t\tthis.textStyles[tag] = this.assign({}, style);\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tpublic deleteTagStyle(tag: string): void {\n\t\tif (tag === \"default\") {\n\t\t\tthis.textStyles[\"default\"] = this.assign({}, MultiStyleText.DEFAULT_TAG_STYLE);\n\t\t} else {\n\t\t\tdelete this.textStyles[tag];\n\t\t}\n\n\t\tthis._style = new PIXI.TextStyle(this.textStyles[\"default\"]);\n\t\tthis.dirty = true;\n\t}\n\n\tprivate getTagRegex(captureName: boolean, captureMatch: boolean): RegExp {\n\t\tlet tagAlternation = Object.keys(this.textStyles).join(\"|\");\n\n\t\tif (captureName) {\n\t\t\ttagAlternation = `(${tagAlternation})`;\n\t\t} else {\n\t\t\ttagAlternation = `(?:${tagAlternation})`;\n\t\t}\n\n\t\tlet reStr = `<${tagAlternation}(?:\\\\s+[A-Za-z0-9_\\\\-]+=(?:\"(?:[^\"]+|\\\\\\\\\")*\"|'(?:[^']+|\\\\\\\\')*'))*\\\\s*>|</${tagAlternation}\\\\s*>`;\n\n\t\tif (captureMatch) {\n\t\t\treStr = `(${reStr})`;\n\t\t}\n\n\t\treturn new RegExp(reStr, \"g\");\n\t}\n\n\tprivate getPropertyRegex(): RegExp {\n\t\treturn new RegExp(`([A-Za-z0-9_\\\\-]+)=(?:\"((?:[^\"]+|\\\\\\\\\")*)\"|'((?:[^']+|\\\\\\\\')*)')`, \"g\");\n\t}\n\n\tprivate _getTextDataPerLine (lines: string[]) {\n\t\tlet outputTextData: TextData[][] = [];\n\t\tlet re = this.getTagRegex(true, false);\n\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tlet tagStack: TagData[] = [{ name: \"default\", properties: {} }];\n\n\t\t// determine the group of word for each line\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineTextData: TextData[] = [];\n\n\t\t\t// find tags inside the string\n\t\t\tlet matches: RegExpExecArray[] = [];\n\t\t\tlet matchArray: RegExpExecArray;\n\n\t\t\twhile (matchArray = re.exec(lines[i])) {\n\t\t\t\tmatches.push(matchArray);\n\t\t\t}\n\n\t\t\t// if there is no match, we still need to add the line with the default style\n\t\t\tif (matches.length === 0) {\n\t\t\t\tlineTextData.push(this.createTextData(lines[i], styleStack[styleStack.length - 1], tagStack[tagStack.length - 1]));\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// We got a match! add the text with the needed style\n\t\t\t\tlet currentSearchIdx = 0;\n\t\t\t\tfor (let j = 0; j < matches.length; j++) {\n\t\t\t\t\t// if index > 0, it means we have characters before the match,\n\t\t\t\t\t// so we need to add it with the default style\n\t\t\t\t\tif (matches[j].index > currentSearchIdx) {\n\t\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\t\tlines[i].substring(currentSearchIdx, matches[j].index),\n\t\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t\t));\n\t\t\t\t\t}\n\n\t\t\t\t\tif (matches[j][0][1] === \"/\") { // reset the style if end of tag\n\t\t\t\t\t\tif (styleStack.length > 1) {\n\t\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t\t\ttagStack.pop();\n\t\t\t\t\t\t}\n\t\t\t\t\t} else { // set the current style\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[matches[j][1]]));\n\n\t\t\t\t\t\tlet properties: { [key: string]: string } = {};\n\t\t\t\t\t\tlet propertyRegex = this.getPropertyRegex();\n\t\t\t\t\t\tlet propertyMatch: RegExpMatchArray;\n\n\t\t\t\t\t\twhile (propertyMatch = propertyRegex.exec(matches[j][0])) {\n\t\t\t\t\t\t\tproperties[propertyMatch[1]] = propertyMatch[2] || propertyMatch[3];\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\ttagStack.push({ name: matches[j][1], properties });\n\t\t\t\t\t}\n\n\t\t\t\t\t// update the current search index\n\t\t\t\t\tcurrentSearchIdx = matches[j].index + matches[j][0].length;\n\t\t\t\t}\n\n\t\t\t\t// is there any character left?\n\t\t\t\tif (currentSearchIdx < lines[i].length) {\n\t\t\t\t\tlineTextData.push(this.createTextData(\n\t\t\t\t\t\tlines[i].substring(currentSearchIdx),\n\t\t\t\t\t\tstyleStack[styleStack.length - 1],\n\t\t\t\t\t\ttagStack[tagStack.length - 1]\n\t\t\t\t\t));\n\t\t\t\t}\n\t\t\t}\n\n\t\t\toutputTextData.push(lineTextData);\n\t\t}\n\n\t\treturn outputTextData;\n\t}\n\n\tprivate getFontString(style: ExtendedTextStyle): string {\n\t\treturn new PIXI.TextStyle(style).toFontString();\n\t}\n\n\tprivate createTextData(text: string, style: ExtendedTextStyle, tag: TagData): TextData {\n\t\treturn {\n\t\t\ttext,\n\t\t\tstyle,\n\t\t\twidth: 0,\n\t\t\theight: 0,\n\t\t\tfontProperties: undefined,\n\t\t\ttag\n\t\t};\n\t}\n\n\tprivate getDropShadowPadding(): number {\n\t\tlet maxDistance = 0;\n\t\tlet maxBlur = 0;\n\n\t\t Object.keys(this.textStyles).forEach((styleKey) => {\n\t\t\tlet { dropShadowDistance, dropShadowBlur } = this.textStyles[styleKey];\n\t\t\tmaxDistance = Math.max(maxDistance, dropShadowDistance || 0);\n\t\t\tmaxBlur = Math.max(maxBlur, dropShadowBlur || 0);\n\t\t});\n\n\t\treturn maxDistance + maxBlur;\n\t}\n\n\tpublic updateText(): void {\n\t\tif (!this.dirty) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis.hitboxes = [];\n\n\t\tthis.texture.baseTexture.resolution = this.resolution;\n\t\tlet textStyles = this.textStyles;\n\t\tlet outputText = this.text;\n\n\t\tif(this._style.wordWrap) {\n\t\t\toutputText = this.wordWrap(this.text);\n\t\t}\n\n\t\t// split text into lines\n\t\tlet lines = outputText.split(/(?:\\r\\n|\\r|\\n)/);\n\n\t\t// get the text data with specific styles\n\t\tlet outputTextData = this._getTextDataPerLine(lines);\n\n\t\t// calculate text width and height\n\t\tlet lineWidths: number[] = [];\n\t\tlet lineYMins: number[] = [];\n\t\tlet lineYMaxs: number[] = [];\n\t\tlet baselines: number[] = [];\n\t\tlet maxLineWidth = 0;\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet lineWidth = 0;\n\t\t\tlet lineYMin = 0;\n\t\t\tlet lineYMax = 0;\n\t\t\tlet baseline = 0;\n\t\t\tfor (let j = 0; j < outputTextData[i].length; j++) {\n\t\t\t\tlet sty = outputTextData[i][j].style;\n\n\t\t\t\tthis.context.font = this.getFontString(sty);\n\n\t\t\t\t// save the width\n\t\t\t\toutputTextData[i][j].width = this.context.measureText(outputTextData[i][j].text).width;\n\n\t\t\t\tif (outputTextData[i][j].text.length !== 0) {\n\t\t\t\t\toutputTextData[i][j].width += (outputTextData[i][j].text.length - 1) * sty.letterSpacing;\n\n\t\t\t\t\tif (j > 0) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing before first character\n\t\t\t\t\t}\n\n\t\t\t\t\tif (j < outputTextData[i].length - 1) {\n\t\t\t\t\t\tlineWidth += sty.letterSpacing / 2; // spacing after last character\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tlineWidth += outputTextData[i][j].width;\n\n\t\t\t\t// save the font properties\n\t\t\t\toutputTextData[i][j].fontProperties = PIXI.TextMetrics.measureFont(this.context.font);\n\n\t\t\t\t// save the height\n\t\t\t\toutputTextData[i][j].height = outputTextData[i][j].fontProperties.fontSize;\n\n\t\t\t\tif (typeof sty.valign === \"number\") {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t- outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\tsty.valign\n\t\t\t\t\t\t\t\t+ outputTextData[i][j].fontProperties.ascent);\n\t\t\t\t} else {\n\t\t\t\t\tlineYMin =\n\t\t\t\t\t\tMath.min(\n\t\t\t\t\t\t\tlineYMin,\n\t\t\t\t\t\t\t-outputTextData[i][j].fontProperties.descent);\n\t\t\t\t\tlineYMax =\n\t\t\t\t\t\tMath.max(\n\t\t\t\t\t\t\tlineYMax,\n\t\t\t\t\t\t\toutputTextData[i][j].fontProperties.ascent);\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tlineWidths[i] = lineWidth;\n\t\t\tlineYMins[i] = lineYMin;\n\t\t\tlineYMaxs[i] = lineYMax;\n\t\t\tmaxLineWidth = Math.max(maxLineWidth, lineWidth);\n\t\t}\n\n\t\t// transform styles in array\n\t\tlet stylesArray = Object.keys(textStyles).map((key) => textStyles[key]);\n\n\t\tlet maxStrokeThickness = stylesArray.reduce((prev, cur) => Math.max(prev, cur.strokeThickness || 0), 0);\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\tlet totalHeight = lineYMaxs.reduce((prev, cur) => prev + cur, 0) - lineYMins.reduce((prev, cur) => prev + cur, 0);\n\n\t\t// define the right width and height\n\t\tlet width = maxLineWidth + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\t\tlet height = totalHeight + 2 * maxStrokeThickness + 2 * dropShadowPadding;\n\n\t\tthis.canvas.width = width * this.resolution;\n\t\tthis.canvas.height = height * this.resolution;\n\n\t\tthis.context.scale(this.resolution, this.resolution);\n\n\t\tthis.context.textBaseline = \"alphabetic\";\n\t\tthis.context.lineJoin = \"round\";\n\n\t\tlet basePositionY = dropShadowPadding + maxStrokeThickness;\n\n\t\tlet drawingData: TextDrawingData[] = [];\n\n\t\t// Compute the drawing data\n\t\tfor (let i = 0; i < outputTextData.length; i++) {\n\t\t\tlet line = outputTextData[i];\n\t\t\tlet linePositionX: number;\n\n\t\t\tswitch (this._style.align) {\n\t\t\t\tcase \"left\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"center\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + (maxLineWidth - lineWidths[i]) / 2;\n\t\t\t\t\tbreak;\n\n\t\t\t\tcase \"right\":\n\t\t\t\t\tlinePositionX = dropShadowPadding + maxStrokeThickness + maxLineWidth - lineWidths[i];\n\t\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tfor (let j = 0; j < line.length; j++) {\n\t\t\t\tlet { style, text, fontProperties, width, height, tag } = line[j];\n\n\t\t\t\tlet linePositionY = basePositionY + fontProperties.ascent;\n\n\t\t\t\tswitch (style.valign) {\n\t\t\t\t\tcase \"top\":\n\t\t\t\t\t\t// no need to do anything\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"baseline\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"middle\":\n\t\t\t\t\t\tlinePositionY += (lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent) / 2;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tcase \"bottom\":\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - lineYMins[i] - fontProperties.ascent - fontProperties.descent;\n\t\t\t\t\t\tbreak;\n\n\t\t\t\t\tdefault:\n\t\t\t\t\t\t// A number - offset from baseline, positive is higher\n\t\t\t\t\t\tlinePositionY += lineYMaxs[i] - fontProperties.ascent - style.valign;\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (style.letterSpacing === 0) {\n\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\ttext,\n\t\t\t\t\t\tstyle,\n\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\twidth,\n\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\ttag\n\t\t\t\t\t});\n\n\t\t\t\t\tlinePositionX += line[j].width;\n\t\t\t\t} else {\n\t\t\t\t\tthis.context.font = this.getFontString(line[j].style);\n\n\t\t\t\t\tfor (let k = 0; k < text.length; k++) {\n\t\t\t\t\t\tif (k > 0 || j > 0) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tlet charWidth = this.context.measureText(text.charAt(k)).width;\n\n\t\t\t\t\t\tdrawingData.push({\n\t\t\t\t\t\t\ttext: text.charAt(k),\n\t\t\t\t\t\t\tstyle,\n\t\t\t\t\t\t\tx: linePositionX,\n\t\t\t\t\t\t\ty: linePositionY,\n\t\t\t\t\t\t\twidth: charWidth,\n\t\t\t\t\t\t\tascent: fontProperties.ascent,\n\t\t\t\t\t\t\tdescent: fontProperties.descent,\n\t\t\t\t\t\t\ttag\n\t\t\t\t\t\t});\n\n\t\t\t\t\t\tlinePositionX += charWidth;\n\n\t\t\t\t\t\tif (k < text.length - 1 || j < line.length - 1) {\n\t\t\t\t\t\t\tlinePositionX += style.letterSpacing / 2;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tbasePositionY += lineYMaxs[i] - lineYMins[i];\n\t\t}\n\n\t\tthis.context.save();\n\n\t\t// First pass: draw the shadows only\n\t\tdrawingData.forEach(({ style, text, x, y }) => {\n\t\t\tif (!style.dropShadow) {\n\t\t\t\treturn; // This text doesn't have a shadow\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet dropFillStyle = style.dropShadowColor;\n\t\t\tif (typeof dropFillStyle === \"number\") {\n\t\t\t\tdropFillStyle = PIXI.utils.hex2string(dropFillStyle);\n\t\t\t}\n\t\t\tthis.context.shadowColor = dropFillStyle;\n\t\t\tthis.context.shadowBlur = style.dropShadowBlur;\n\t\t\tthis.context.shadowOffsetX = Math.cos(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\t\t\tthis.context.shadowOffsetY = Math.sin(style.dropShadowAngle) * style.dropShadowDistance * this.resolution;\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\tthis.context.restore();\n\n\t\t// Second pass: draw the strokes only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.stroke === undefined || !style.strokeThickness) {\n\t\t\t\treturn; // Skip this step if we have no stroke\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\tlet strokeStyle = style.stroke;\n\t\t\tif (typeof strokeStyle === \"number\") {\n\t\t\t\tstrokeStyle = PIXI.utils.hex2string(strokeStyle);\n\t\t\t}\n\n\t\t\tthis.context.strokeStyle = strokeStyle;\n\t\t\tthis.context.lineWidth = style.strokeThickness;\n\n\t\t\tthis.context.strokeText(text, x, y);\n\t\t});\n\n\t\t// Third pass: draw the fills only\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tif (style.fill === undefined) {\n\t\t\t\treturn; // Skip this step if we have no fill\n\t\t\t}\n\n\t\t\tthis.context.font = this.getFontString(style);\n\n\t\t\t// set canvas text styles\n\t\t\tlet fillStyle = style.fill;\n\t\t\tif (typeof fillStyle === \"number\") {\n\t\t\t\tfillStyle = PIXI.utils.hex2string(fillStyle);\n\t\t\t} else if (Array.isArray(fillStyle)) {\n\t\t\t\tfor (let i = 0; i < fillStyle.length; i++) {\n\t\t\t\t\tlet fill = fillStyle[i];\n\t\t\t\t\tif (typeof fill === \"number\") {\n\t\t\t\t\t\tfillStyle[i] = PIXI.utils.hex2string(fill);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis.context.fillStyle = this._generateFillStyle(new PIXI.TextStyle(style), [text]) as string | CanvasGradient;\n\t\t\t// Typecast required for proper typechecking\n\n\t\t\tthis.context.fillText(text, x, y);\n\t\t});\n\n\t\t// Fourth pass: collect the bounding boxes and draw the debug information\n\t\tdrawingData.forEach(({ style, text, x, y, width, ascent, descent, tag }) => {\n\t\t\tlet offset = -this._style.padding - this.getDropShadowPadding();\n\n\t\t\tthis.hitboxes.push({\n\t\t\t\ttag,\n\t\t\t\thitbox: new PIXI.Rectangle(x + offset, y - ascent + offset, width, ascent + descent)\n\t\t\t});\n\n\t\t\tlet debugSpan = style.debug === undefined\n\t\t\t\t? MultiStyleText.debugOptions.spans.enabled\n\t\t\t\t: style.debug;\n\n\t\t\tif (debugSpan) {\n\t\t\t\tthis.context.lineWidth = 1;\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bounding) {\n\t\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bounding;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.rect(x, y - ascent, width, ascent + descent);\n\t\t\t\t\tthis.context.fill();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t\tthis.context.stroke(); // yes, twice\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.baseline) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.baseline;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y);\n\t\t\t\t\tthis.context.lineTo(x + width, y);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.top) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.top;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y - ascent);\n\t\t\t\t\tthis.context.lineTo(x + width, y - ascent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.bottom) {\n\t\t\t\t\tthis.context.strokeStyle = MultiStyleText.debugOptions.spans.bottom;\n\t\t\t\t\tthis.context.beginPath();\n\t\t\t\t\tthis.context.moveTo(x, y + descent);\n\t\t\t\t\tthis.context.lineTo(x + width, y + descent);\n\t\t\t\t\tthis.context.closePath();\n\t\t\t\t\tthis.context.stroke();\n\t\t\t\t}\n\n\t\t\t\tif (MultiStyleText.debugOptions.spans.text) {\n\t\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\t\tthis.context.strokeText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.fillText(tag.name, x, y - ascent + 8);\n\t\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${(ascent + descent).toFixed(2)}`, x, y - ascent + 16);\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\tif (MultiStyleText.debugOptions.objects.enabled) {\n\t\t\tif (MultiStyleText.debugOptions.objects.bounding) {\n\t\t\t\tthis.context.fillStyle = MultiStyleText.debugOptions.objects.bounding;\n\t\t\t\tthis.context.beginPath();\n\t\t\t\tthis.context.rect(0, 0, width, height);\n\t\t\t\tthis.context.fill();\n\t\t\t}\n\n\t\t\tif (MultiStyleText.debugOptions.objects.text) {\n\t\t\t\tthis.context.fillStyle = \"#ffffff\";\n\t\t\t\tthis.context.strokeStyle = \"#000000\";\n\t\t\t\tthis.context.lineWidth = 2;\n\t\t\t\tthis.context.font = \"8px monospace\";\n\t\t\t\tthis.context.strokeText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t\tthis.context.fillText(`${width.toFixed(2)}x${height.toFixed(2)}`, 0, 8, width);\n\t\t\t}\n\t\t}\n\n\t\tthis.updateTexture();\n\t}\n\n\tprotected wordWrap(text: string): string {\n\t\t// Greedy wrapping algorithm that will wrap words as the line grows longer than its horizontal bounds.\n\t\tlet result = \"\";\n\t\tlet re = this.getTagRegex(true, true);\n\n\t\tconst lines = text.split(\"\\n\");\n\t\tconst wordWrapWidth = this._style.wordWrapWidth;\n\t\tlet styleStack = [this.assign({}, this.textStyles[\"default\"])];\n\t\tthis.context.font = this.getFontString(this.textStyles[\"default\"]);\n\n\t\tfor (let i = 0; i < lines.length; i++) {\n\t\t\tlet spaceLeft = wordWrapWidth;\n\t\t\tconst tagSplit = lines[i].split(re);\n\t\t\tlet firstWordOfLine = true;\n\n\t\t\tfor (let j = 0; j < tagSplit.length; j++) {\n\t\t\t\tif (re.test(tagSplit[j])) {\n\t\t\t\t\tresult += tagSplit[j];\n\t\t\t\t\tif (tagSplit[j][1] === \"/\") {\n\t\t\t\t\t\tj += 2;\n\t\t\t\t\t\tstyleStack.pop();\n\t\t\t\t\t} else {\n\t\t\t\t\t\tj++;\n\t\t\t\t\t\tstyleStack.push(this.assign({}, styleStack[styleStack.length - 1], this.textStyles[tagSplit[j]]));\n\t\t\t\t\t\tj++;\n\t\t\t\t\t}\n\t\t\t\t\tthis.context.font = this.getFontString(styleStack[styleStack.length - 1]);\n\t\t\t\t} else {\n\t\t\t\t\tconst words = tagSplit[j].split(\" \");\n\n\t\t\t\t\tfor (let k = 0; k < words.length; k++) {\n\t\t\t\t\t\tconst wordWidth = this.context.measureText(words[k]).width;\n\n\t\t\t\t\t\tif (this._style.breakWords && wordWidth > spaceLeft) {\n\t\t\t\t\t\t\t// Part should be split in the middle\n\t\t\t\t\t\t\tconst characters = words[k].split('');\n\n\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\tspaceLeft -= this.context.measureText(\" \").width;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tfor (let c = 0; c < characters.length; c++) {\n\t\t\t\t\t\t\t\tconst characterWidth = this.context.measureText(characters[c]).width;\n\n\t\t\t\t\t\t\t\tif (characterWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t\tresult += `\\n${characters[c]}`;\n\t\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - characterWidth;\n\t\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\t\tresult += characters[c];\n\t\t\t\t\t\t\t\t\tspaceLeft -= characterWidth;\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} else if(this._style.breakWords) {\n\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\tspaceLeft -= wordWidth;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tconst paddedWordWidth =\n\t\t\t\t\t\t\t\twordWidth + (k > 0 ? this.context.measureText(\" \").width : 0);\n\n\t\t\t\t\t\t\tif (paddedWordWidth > spaceLeft) {\n\t\t\t\t\t\t\t\t// Skip printing the newline if it's the first word of the line that is\n\t\t\t\t\t\t\t\t// greater than the word wrap width.\n\t\t\t\t\t\t\t\tif (!firstWordOfLine) {\n\t\t\t\t\t\t\t\t\tresult += \"\\n\";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t\tspaceLeft = wordWrapWidth - wordWidth;\n\t\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\t\tspaceLeft -= paddedWordWidth;\n\n\t\t\t\t\t\t\t\tif (k > 0) {\n\t\t\t\t\t\t\t\t\tresult += \" \";\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\tresult += words[k];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t\tfirstWordOfLine = false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\n\t\t\tif (i < lines.length - 1) {\n\t\t\t\tresult += '\\n';\n\t\t\t}\n\t\t}\n\n\t\treturn result;\n\t}\n\n\tprotected updateTexture() {\n\t\tconst texture = this._texture;\n\n\t\tlet dropShadowPadding = this.getDropShadowPadding();\n\n\t\ttexture.baseTexture.hasLoaded = true;\n\t\ttexture.baseTexture.resolution = this.resolution;\n\n\t\ttexture.baseTexture.realWidth = this.canvas.width;\n\t\ttexture.baseTexture.realHeight = this.canvas.height;\n\t\ttexture.baseTexture.width = this.canvas.width / this.resolution;\n\t\ttexture.baseTexture.height = this.canvas.height / this.resolution;\n\t\ttexture.trim.width = texture.frame.width = this.canvas.width / this.resolution;\n\t\ttexture.trim.height = texture.frame.height = this.canvas.height / this.resolution;\n\n\t\ttexture.trim.x = -this._style.padding - dropShadowPadding;\n\t\ttexture.trim.y = -this._style.padding - dropShadowPadding;\n\n\t\ttexture.orig.width = texture.frame.width - (this._style.padding + dropShadowPadding) * 2;\n\t\ttexture.orig.height = texture.frame.height - (this._style.padding + dropShadowPadding) * 2;\n\n\t\t// call sprite onTextureUpdate to update scale if _width or _height were set\n\t\tthis._onTextureUpdate();\n\n\t\ttexture.baseTexture.emit('update', texture.baseTexture);\n\n\t\tthis.dirty = false;\n\t}\n\n\t// Lazy fill for Object.assign\n\tprivate assign(destination: any, ...sources: any[]): any {\n\t\tfor (let source of sources) {\n\t\t\tfor (let key in source) {\n\t\t\t\tdestination[key] = source[key];\n\t\t\t}\n\t\t}\n\n\t\treturn destination;\n\t}\n}\n"],"names":["INTERACTION_EVENTS","text","styles","_super","_this","forEach","event","on","e","handleInteraction","tslib_1.__extends","MultiStyleText","ev","localPoint","data","getLocalPosition","this","targetTag","hitboxes","reduce","prev","hitbox","undefined","contains","x","y","tag","Object","style","textStyles","assign","DEFAULT_TAG_STYLE","_style","PIXI","TextStyle","dirty","captureName","captureMatch","tagAlternation","keys","join","reStr","RegExp","lines","outputTextData","re","getTagRegex","styleStack","tagStack","name","properties","i","length","lineTextData","matches","matchArray","exec","push","createTextData","currentSearchIdx","j","index","substring","pop","propertyRegex","getPropertyRegex","propertyMatch","toFontString","width","height","fontProperties","maxDistance","maxBlur","styleKey","_a","dropShadowBlur","Math","max","texture","baseTexture","resolution","outputText","wordWrap","split","_getTextDataPerLine","lineWidths","lineYMins","lineYMaxs","maxLineWidth","lineWidth","lineYMin","lineYMax","sty","context","font","getFontString","measureText","letterSpacing","TextMetrics","measureFont","fontSize","valign","min","descent","ascent","maxStrokeThickness","map","key","cur","strokeThickness","dropShadowPadding","getDropShadowPadding","canvas","scale","textBaseline","lineJoin","basePositionY","drawingData","line","linePositionX","align","width_1","linePositionY","k","charWidth","charAt","save","dropShadow","dropFillStyle","dropShadowColor","utils","hex2string","shadowColor","shadowBlur","shadowOffsetX","cos","dropShadowAngle","dropShadowDistance","shadowOffsetY","sin","fillText","restore","stroke","strokeStyle","strokeText","fill","fillStyle","Array","isArray","_generateFillStyle","offset","padding","Rectangle","debug","debugOptions","spans","enabled","bounding","beginPath","rect","baseline","moveTo","lineTo","closePath","top","bottom","toFixed","objects","updateTexture","result","wordWrapWidth","spaceLeft","tagSplit","firstWordOfLine","test","words","wordWidth","breakWords","characters","c","characterWidth","paddedWordWidth","_texture","hasLoaded","realWidth","realHeight","trim","frame","orig","_onTextureUpdate","emit","destination","_i","sources","sources_1","source","PI","fillGradientType","TEXT_GRADIENT","LINEAR_VERTICAL","fontFamily","fontStyle","fontVariant","fontWeight","lineHeight","miterLimit","Text"],"mappings":"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"}