<!doctype html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130030503-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-130030503-3');
    </script>

    <meta charset="utf-8">
    <meta id="viewport" name="viewport" content="">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <style>* {padding: 0; margin: 0; overflow: hidden;}</style>

    <title>Crypto Climber</title>
    <meta property="og:title" content="Crypto Climber" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://cryptoclimber.decent.org/" />
    <meta property="og:image" content="https://cryptoclimber.decent.org/og.png" />
    <meta property="og:description" content="Fun little game about bitcoin trading" />

    <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
    <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
    <link rel="icon" type="image/png" sizes="96x96" href="/favicon-96x96.png">

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.5/pixi.min.js"></script>
    <script src="pixi-multistyle-text/0.6.0/pixi-multistyle-text.umd.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  </head>
  <body>
    <script>


// ===== constants =====

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = parseInt(getQueryParam('days'), 10) || 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY

const PAST_LENGTH_DAYS = Math.round(GAME_LENGTH_DAYS / 2)
const PAST_LENGTH_TICKS = PAST_LENGTH_DAYS * TICKS_PER_DAY

const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const Y_SCALE_FACTOR = 1000

const BANDS = 20

const OFFSET_X = 0.25
const SMOOTH_FACTOR_Y = 50

const MARGIN = 15
const BUTTON_WIDTH = 160
const BUTTON_HEIGHT = 80

const SHOW_PRICE = false
const SHOW_DEBUG = false
const SHOW_FPS = parseBoolean(getQueryParam('fps')) || false

const SPEED_LEVELS = [6.0, 4.8, 3.6, 2.4, 1.2]
const ZOOM_LEVELS = [1.6, 1.4, 1.2, 1.0, 0.8]
const DEFAULT_LEVEL = 2

const DEFAULT_SPEED = SPEED_LEVELS[DEFAULT_LEVEL]
const DEFAULT_ZOOM = ZOOM_LEVELS[DEFAULT_LEVEL]

const WARP_SPEED_DELTA = (SPEED_LEVELS[0] - SPEED_LEVELS[1]) / 30
const WARP_ZOOM_DELTA = (ZOOM_LEVELS[0] - ZOOM_LEVELS[1]) / 30

const INTRO =
  'How good are you at trading' +
  '\na ' + GAME_LENGTH_DAYS + ' day sample of' +
  '\nhistorical Bitcoin prices?' +
  '<strong>' +
  '\n\nPress [UP] to go LONG' +
  '\nPress [DOWN] to sell SHORT' +
  '\nPress [SPACE] to close position ' +
  '</strong>' +
  '\n\nPress [LEFT] / [RIGHT] to change speed ' +
  '\nPress [P] to pause game ' +
  '\n\n<strong>Press [SPACE] to start!</strong>'

const HODL_NAME = 'Buy and hold'

const SHEET_URL = 'https://script.google.com/macros/s/AKfycbyDTk5pYHGjgHartXZZX876CZbKYa_kKljZDEOJ1dylwVSn1Mk/exec'

const DEFAULT_TEXTS = Object.freeze({
  summary: INTRO,
  highscores: '',
  iteration: '',
  funds: '',
  price: '',
  debug: '',
})

const COLOR_BUTTON_INACTIVE = 0xffffff
const COLOR_BUTTON_ACTIVE = 0xff00ff
const COLOR_BUTTON_PRESSED = 0xffff00
const COLOR_BUTTON_DISABLED = 0x444444

// ===== global variables =====

let screenWidth = window.innerWidth
let screenHeight = window.innerHeight

let speed = DEFAULT_SPEED
let zoom = DEFAULT_ZOOM

let texts = Object.assign({}, DEFAULT_TEXTS)

let entities = {
  gamespace: null,
  tradelines: null,
  tradelabels: null,
  ui: null,
  messages: {
    iteration: null,
    funds: null,
    summary: null,
    highscores: null,
    price: null,
    debug: null,
    pause: null,
  },
  logos: null,
  graph: null,
  player: null,
}

let assets = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
  scores: [],
}

let priceData = {}
let player = getQueryParam('player')

let viewPortX = 0
let viewPortY = 0

let time = 0
let tick = -1

let gameOver = false
let gameStarted = false
let paused = false

let input = {
  short: false,
  long: false,
  speedLevel: DEFAULT_LEVEL,
}

let fps = 60

// ===== startup code =====

if (window.navigator.userAgent.includes('iPhone') || window.navigator.userAgent.includes('Android')) {
  document.getElementById("viewport").setAttribute("content",
      "minimal-ui, width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5, user-scalable=no")
}

const app = new PIXI.Application({
  width: window.innerWidth,
  height: window.innerHeight,
  antialias: false,
  transparent: false,
  resolution: window.devicePixelRatio,
  preserveDrawingBuffer: true,
});

// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.view.style.overflow = 'hidden';
app.renderer.autoResize = true;

screenWidth = window.innerWidth
screenHeight = window.innerHeight
app.renderer.resize(screenWidth, screenHeight);

document.body.appendChild(app.view);

PIXI.loader
  .add('prices', 'btc1h.json')
  .load(() => {
    // TODO: load font concurrently with resources
    WebFont.load({
      google: {
        families: ['B612 Mono']
      },
      active: setup
    })
  });

window.onresize = listenerResize

window.onload = () => {
  listenerResize(null)
}


// ===== setup and layout =====

function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  gameOver = false
  gameStarted = false

  time = 0
  tick = -1
  speed = DEFAULT_SPEED
  zoom = DEFAULT_ZOOM

  input = {
    short: false,
    long: false,
    speedLevel: DEFAULT_LEVEL,
  }

  assets.funds = INIT_FUNDS
  assets.trades = []
  assets.scores = []
  assets.trade = null

  priceData = parsePriceData(PIXI.loader.resources.prices.data, GAME_LENGTH_TICKS)

  entities.gamespace = new PIXI.Container()
  entities.gamespace.interactive = false
  entities.gamespace.interactiveChildren = false
  entities.gamespace.addChild(createGrid())

  entities.graph = createGraph()
  entities.gamespace.addChild(entities.graph)
  entities.gamespace.addChild(entities.graph.mask)

  entities.player = createPlayer()
  entities.gamespace.addChild(entities.player)

  entities.tradelines = new PIXI.Container()
  entities.gamespace.addChild(entities.tradelines)

  entities.tradelabels = new PIXI.Container()
  entities.gamespace.addChild(entities.tradelabels)

  app.stage.addChild(entities.gamespace)

  texts = Object.assign({}, DEFAULT_TEXTS)
  setupUI(screenWidth, screenHeight);

  onNeutral()
  showControls(false)
  setViewPort(0, 0, OFFSET_X)

  addInputListeners()
  app.ticker.add(update)
}

function setupUI(width, height) {
  app.stage.removeChild(entities.ui)

  let uiContainer = new PIXI.Container()
  entities.ui = uiContainer

  let {messagesContainer, messages} = createMessages(width, height, MARGIN)
  uiContainer.addChild(messagesContainer)
  entities.messages = messages

  entities.logos = createLogos(width, height, MARGIN)
  uiContainer.addChild(entities.logos)

  entities.smallLogo = createSmallLogo(width, height, MARGIN)
  uiContainer.addChild(entities.smallLogo)

  entities.longButton = createButton("\u25B3\u2009Long\u2009",
    width - BUTTON_WIDTH - MARGIN, height - 3 * BUTTON_HEIGHT - 5 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, input.long,
    (pressed) => {
      if (pressed) {
        onLong()
      }
    })
  uiContainer.addChild(entities.longButton)

  entities.neutralButton = createButton("Neutral",
    width - BUTTON_WIDTH - MARGIN, height - 2 * BUTTON_HEIGHT - 3 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, !input.long && !input.short,
    (pressed) => {
      if (pressed) {
        onNeutral()
      }
    })
  uiContainer.addChild(entities.neutralButton)

  entities.shortButton = createButton("\u25BD\u2009Short",
    width - BUTTON_WIDTH - MARGIN, height - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, input.short,
    (pressed) => {
      if (pressed) {
        onShort()
      }
    })
  uiContainer.addChild(entities.shortButton)

  entities.speedDown = createButton("<\u2009Slow",
    MARGIN, height - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, false,
    (pressed) => {
      if (pressed) {
        onSpeedDown()
      }
      updateSpeedButtons(pressed, false)
   })
  uiContainer.addChild(entities.speedDown)

  entities.speedUp = createButton("Fast\u2009>",
    3 * MARGIN + BUTTON_WIDTH, height - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, false,
    (pressed) => {
      if (pressed) {
        onSpeedUp()
      }
      updateSpeedButtons(false, pressed)
    })
  uiContainer.addChild(entities.speedUp)

  showControls(isGameRunning())
  uiContainer.interactive = true
  uiContainer.on('tap', listenerGlobalTap)
  uiContainer.hitArea = new PIXI.Rectangle(0, 0, width, height)

  app.stage.addChild(uiContainer)
}

function showControls(show) {
  entities.longButton.visible =
  entities.neutralButton.visible =
  entities.shortButton.visible =
  entities.speedUp.visible =
  entities.speedDown.visible =
  show
}

function updateSpeedButtons(downPressed = false, upPressed = false) {
  entities.speedDown.tint = entities.speedDown.label.style.fill = input.speedLevel > 0 ?
    (downPressed ? COLOR_BUTTON_PRESSED : COLOR_BUTTON_INACTIVE) : COLOR_BUTTON_DISABLED
  entities.speedUp.tint = entities.speedUp.label.style.fill = input.speedLevel < SPEED_LEVELS.length - 1 ?
    (upPressed ? COLOR_BUTTON_PRESSED : COLOR_BUTTON_INACTIVE) : COLOR_BUTTON_DISABLED
}

function updateTexts() {
  entities.messages.summary.text = texts.summary
  entities.messages.highscores.text = texts.highscores
  entities.messages.iteration.text = texts.iteration
  entities.messages.funds.text = texts.funds
  if (SHOW_PRICE) {
    entities.messages.price.text = texts.price
  }
  if (SHOW_DEBUG) {
    entities.messages.debug.text = texts.debug
  }
  if (SHOW_FPS) {
    entities.messages.fps.text = texts.fps
  }
}

// ===== update loop =====

function update(dt) {
  if (!gameStarted || paused) {
    return
  }

  targetSpeed = SPEED_LEVELS[input.speedLevel]
  targetzoom = ZOOM_LEVELS[input.speedLevel]

  if (speed < targetSpeed) {
    speed = Math.min(targetSpeed, speed + WARP_SPEED_DELTA)
    zoom = Math.min(targetzoom, zoom + WARP_ZOOM_DELTA)
  } else if (speed > targetSpeed) {
    speed = Math.max(targetSpeed, speed - WARP_SPEED_DELTA)
    zoom = Math.max(targetzoom, zoom - WARP_ZOOM_DELTA)
  }

  // 60 is the target fps
  time += dt / (speed * 60 / TICKS_PER_DAY)
  var i = Math.floor(time)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      gameStarted = false
      showGameOver()
    }
    return
  }

  if (i > tick) {
    tick = i
    handleInput(tick)
  }

  var x = time * GRAPH_X_GRANULARITY_PX
  var y = Y_SCALE_FACTOR * priceData.scale * ((priceData.series[tick] - priceData.series[0])
    + (time - tick) * (priceData.series[tick + 1] - priceData.series[tick]))

  if (assets.trade) {
    recalculateTrade(assets.trade, tick)
    updateTrade(assets.trade, x, y)
  }
  entities.graph.mask.position.x = x
  setViewPort(x, (viewPortY + (y - viewPortY) / SMOOTH_FACTOR_Y), OFFSET_X)
  updatePlayer(x, y)
  updateMessages(tick)
}

function setViewPort(x, y, xOffset) {
  viewPortX = x
  viewPortY = y
  entities.gamespace.scale.x = zoom
  entities.gamespace.scale.y = -zoom
  entities.gamespace.position.x = -(x * zoom - screenWidth / 2 - (screenWidth * xOffset))
  entities.gamespace.position.y = -(-y * zoom - screenHeight / 2)
}

function updatePlayer(x, y) {
  entities.player.x = x
  entities.player.y = y
  entities.player.alpha = assets.trade ? 0.5 : 0.2
}

function startGame() {
  texts.summary = ''
  texts.highscores = ''
  updateTexts()
  entities.logos.visible = false
  entities.smallLogo.visible = true
  showControls(true)
  gameStarted = true
  pauseGame(false)
}

function pauseGame(p) {
  paused = entities.messages.pause.visible = p && isGameRunning()
}

function onSpeedUp() {
  input.speedLevel = Math.min(input.speedLevel + 1, SPEED_LEVELS.length - 1)
}

function onSpeedDown() {
  input.speedLevel = Math.max(input.speedLevel - 1, 0)
}

function onLong() {
  input.short = false
  input.long = true
  entities.longButton.tint = COLOR_BUTTON_ACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_INACTIVE
  entities.shortButton.tint = COLOR_BUTTON_INACTIVE
}

function onShort() {
  input.short = true
  input.long = false
  entities.longButton.tint = COLOR_BUTTON_INACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_INACTIVE
  entities.shortButton.tint = COLOR_BUTTON_ACTIVE
}

function onNeutral() {
  input.long = false
  input.short = false
  entities.longButton.tint = COLOR_BUTTON_INACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_ACTIVE
  entities.shortButton.tint = COLOR_BUTTON_INACTIVE
}

function handleInput(i) {
  if (input.long && !input.short) {
    // LONG
    if (assets.trade) {
      if (assets.trade.isLong) {
        return
      } else {
        exitTrade(i)
      }
    }
    enterTrade(true, i, assets.funds)
  } else if (!input.long && input.short) {
    // SHORT
    if (assets.trade) {
      if (!assets.trade.isLong) {
        return
      } else {
        exitTrade(i)
      }
    }
    enterTrade(false, i, assets.funds)
  } else {
    // NEUTRAL
    if (assets.trade) {
      exitTrade(i)
    }
  }
}

function updateMessages(i) {
  texts.summary = ''
  texts.iteration = 'Day ' + (Math.floor(i / TICKS_PER_DAY) + 1) + ' of ' + GAME_LENGTH_DAYS

  var equity = assets.funds + (assets.trade ? assets.trade.current : 0)
  texts.funds = 'Equity $' + Math.round(equity)

  if (SHOW_PRICE) {
    texts.price = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    texts.debug =
      'inputs:' + (input.short?'S':' ') + (input.long?'L':' ') + (input.warp?'W':' ') + ' S' + (input.speedLevel+1)
      + '\nspeed:' + speed.toFixed(2) + ' (sec/day @ 60fps)'
      + '\nzoom:' + zoom.toFixed(2)
      + '\ntick:' + tick
      + ' x:' + viewPortX.toFixed(2)
      + ' y:' + viewPortY.toFixed(2)

      if (assets.trades.length > (assets.trade ? 1 : 0)) {
        let lastTrade = assets.trades[assets.trades.length - (assets.trade ? 2 : 1)]
        texts.debug +=
          '\n\nLast: ' + (lastTrade.isLong ? 'LONG' : 'SHORT')
          + '\n bar:(' + lastTrade.barOpen + ' \u2192 ' + lastTrade.barClose + ')'
          + '\n price:(' + lastTrade.priceOpen.toFixed(2) + ' \u2192 ' + lastTrade.priceClose.toFixed(2) + ')'
          + '\n profit:' + (lastTrade.current - lastTrade.margin).toFixed(2)
      }
      if (assets.trade) {
        let currentTrade = assets.trade
        texts.debug +=
          '\n\nCurrent: ' + (currentTrade.isLong ? 'LONG' : 'SHORT')
          + '\n bar:(' + currentTrade.barOpen + ' \u2192 ' + currentTrade.barClose + ')'
          + '\n price:(' + currentTrade.priceOpen.toFixed(2) + ' \u2192 ' + currentTrade.priceClose.toFixed(2) + ')'
          + '\n profit:' + (currentTrade.current - currentTrade.margin).toFixed(2)
      }
  }
  if (SHOW_FPS) {
    fps = fps * 0.95 + app.ticker.FPS * 0.05
    texts.fps = 'FPS:' + fps.toFixed(0) + ' (' + app.ticker.FPS.toFixed(2) + ')'
  }

  updateTexts()
}

function showGameOver() {
  onNeutral()
  showControls(false)
  if (assets.trade) {
    exitTrade(GAME_LENGTH_TICKS)
  }
  updateMessages(GAME_LENGTH_TICKS - 1)
  zoomOutFull()

  const profit = assets.funds - INIT_FUNDS
  const returns = profit / INIT_FUNDS
  const hodlReturns = priceData.series[GAME_LENGTH_TICKS] / priceData.series[0] - 1
  const beatsHodl = returns > hodlReturns

  setTimeout(() => {
    if (!player) {
      player = window.prompt('Nick name?') || 'anonymous';
    }
    addScore(true, player, returns, assets.trades.length)
    addScore(false, HODL_NAME, hodlReturns, 1)
    showScores()
    saveResult(returns, hodlReturns, assets.trades)
  })
}

function zoomOutFull() {
  zoom = screenWidth / (GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX)
  setViewPort(GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX / 2, 0, 0)
}


// ===== 'create' methods =====

function createGraph() {
  const p0 = priceData.series[0]
  const past = priceData.pastSeries.length

  let graph = new PIXI.Graphics()
  graph.lineStyle(2, 0xffffff)
  graph.position.set(0, 0)
  for (let i = 0; i < priceData.series.length - 1; i++) {
    graph
      .moveTo(GRAPH_X_GRANULARITY_PX * i,
        Y_SCALE_FACTOR * priceData.scale * (priceData.series[i] - p0))
      .lineTo(GRAPH_X_GRANULARITY_PX * (i + 1),
        Y_SCALE_FACTOR * priceData.scale * (priceData.series[i + 1] - p0))
  }

  graph.position.set(0, 0)
  for (let i = 0; i < past; i++) {
    graph.lineStyle(2, 0x666666, i / past)
      .moveTo(GRAPH_X_GRANULARITY_PX * (i + 1 - past),
        Y_SCALE_FACTOR * priceData.scale * (priceData.pastSeries[i] - p0))
      .lineTo(GRAPH_X_GRANULARITY_PX * (i + 2 - past),
        Y_SCALE_FACTOR * priceData.scale * (priceData.pastSeries[i + 1] - p0))
    graph.addChild(graph)
  }

  // Note: you have to add both 'graph' and 'graph.mask' to the gamespace container
  let width = (PAST_LENGTH_TICKS + GAME_LENGTH_TICKS) * GRAPH_X_GRANULARITY_PX
  let yMin = Y_SCALE_FACTOR * priceData.scale * p0 * (Math.pow(0.9, BANDS) - 1)
  let yMax = Y_SCALE_FACTOR * priceData.scale * p0 * (Math.pow(1.1, BANDS) - 1)

  graph.mask = new PIXI.Graphics()
  graph.mask.isMask = true
  graph.mask.drawRect(-width, yMin, width, yMax - yMin)

  return graph
}

function createButton(text, x, y, w, h, initialState, callback) {
  const g = new PIXI.Graphics()

  const txt = new PIXI.Text(text, TEXT_STYLE.clone())
  txt.x = (w - txt.width) / 2
  txt.y = (h - txt.height) / 2
  g.addChild(txt)
  g.label = txt

  g.lineStyle(2, COLOR_BUTTON_INACTIVE, 1);
  g.beginFill(COLOR_BUTTON_INACTIVE, 0.25);
  g.drawRoundedRect(0, 0, w, h, 15);
  g.endFill();
  g.tint = initialState ? COLOR_BUTTON_ACTIVE : COLOR_BUTTON_INACTIVE

  g.x = x
  g.y = y

  g.buttonMode = true
  g.interactive = true
  g.interactiveChildren = false
  g.buttonStates = new Set()
  g.buttonLastState = false

  // hacks to ensure reasonable multitouch behavior
  const f = e => {
    const release = e.type == 'pointerup' || e.type == 'pointerupoutside' || e.type =='pointercancel'
    const pressing = !release && app.renderer.plugins.interaction.hitTest(e.data.global, g) && e.data.buttons == 1
    const id = e.data.pointerId
    if (pressing) {
      g.buttonStates.add(id)
    } else {
      g.buttonStates.delete(id)
    }
    // console.log(text, pressing, g.buttonStates, e.type, id)
    const state = g.buttonStates.size != 0
    if (g.buttonLastState != state) {
      g.buttonLastState = state
      callback(state)
    } 
  }

  g.on('pointermove', f)
  g.on('pointerdown', f)
  g.on('pointerup', f)
  g.on('pointerupoutside', f)
  g.on('pointercancel', f)

  return g
}

function createMessages(width, height, margin) {
  let messagesContainer = new PIXI.Container()
  let messages = {}

  const ROW_HEIGHT = 30
  let x = margin
  let y = margin

  messages.iteration = new PIXI.Text(texts.iteration, TEXT_STYLE)
  messages.iteration.position.set(x, y)
  messagesContainer.addChild(messages.iteration)
  y += ROW_HEIGHT

  messages.funds = new PIXI.Text(texts.funds, TEXT_STYLE)
  messages.funds.position.set(x, y)
  messagesContainer.addChild(messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    messages.price = new PIXI.Text(texts.price, TEXT_STYLE)
    messages.price.position.set(x, y)
    messagesContainer.addChild(messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    let style = TEXT_STYLE.clone()
    style.align = 'left'
    style.fontSize = 20
    messages.debug = new PIXI.Text(texts.debug, style)
    messages.debug.position.set(x, y + ROW_HEIGHT)
    messagesContainer.addChild(messages.debug)
  }

  if (SHOW_FPS) {
    let style = TEXT_STYLE.clone()
    style.fontSize = 16
    messages.fps = new PIXI.Text(texts.fps, style)
    messages.fps.anchor.set(0.5, 0.0)
    messages.fps.position.set(width / 2, margin)
    messagesContainer.addChild(messages.fps)
  }

  messages.summary = new MultiStyleText(texts.summary, TEXT_MULTI_STYLE)
  messages.summary.position.set(width / 2, height / 2 + margin)
  messages.summary.anchor.set(0.5, 0.0)
  messagesContainer.addChild(messages.summary)

  messages.highscores = new MultiStyleText(texts.highscores, TEXT_MULTI_STYLE)
  messages.highscores.position.set(width / 2, height / 2)
  messages.highscores.anchor.set(0.5, 0.5)
  messagesContainer.addChild(messages.highscores)

  let style = TEXT_STYLE.clone()
  style.fontSize = 48
  messages.pause = new PIXI.Text('PAUSED', style)
  messages.pause.anchor.set(0.5, 0.5)
  messages.pause.position.set(width / 2, height / 2)
  messages.pause.visible = paused
  messagesContainer.addChild(messages.pause)

  return {messagesContainer, messages}
}

function createLogos(width, height, margin) {
  let logoContainer = new PIXI.Container()

  let logo = new PIXI.Sprite.from('logo_vertical.png')
  logo.position.set(width / 2, height / 2 - margin)
  logo.anchor.set(0.5, 1.0)
  logoContainer.addChild(logo)

  let createdBy = new PIXI.Sprite.from('created.png')
  createdBy.position.set(margin, height - margin)
  createdBy.anchor.set(0.0, 1.0)
  createdBy.scale.set(0.5)
  createdBy.interactive = true
  createdBy.buttonMode = true
  createdBy.on('click', () => { window.location.href = 'https://decent.org/' })
  createdBy.on('tap', () => { window.location.href = 'https://decent.org/' })
  logoContainer.addChild(createdBy)

  if (document.fullscreenEnabled && document.exitFullscreen && app.view.requestFullscreen) {
    let fullscreen = new PIXI.Sprite.from(!document.fullscreenElement ?
      'fullscreen_enter.png' : 'fullscreen_exit.png')
    fullscreen.position.set(margin, margin)
    fullscreen.anchor.set(0.0, 0.0)
    fullscreen.scale.set(0.25)
    fullscreen.interactive = true
    fullscreen.buttonMode = true
    fullscreen.on('click', toggleFullScreen)
    fullscreen.on('tap', toggleFullScreen)
    logoContainer.addChild(fullscreen)
  }

  logoContainer.visible = isMainScreen()
  return logoContainer
}

function toggleFullScreen() {
  if (!document.fullscreenElement && app.view.requestFullscreen) {
    app.view.requestFullscreen()
  } else if (document.exitFullscreen) {
    document.exitFullscreen()
  }
}

function createSmallLogo(width, height, margin) {
  let logo = new PIXI.Sprite.from('logo.png')
  logo.position.set(width - margin, margin)
  logo.anchor.set(1.0, 0.0)
  logo.scale.set(0.5)
  logo.visible = !isMainScreen()
  return logo
}

function createGrid() {
  let grid = new PIXI.Container()

  const p0 = priceData.series[0]

  const gradHeight = 256
  const grad = gradientTexture(1, gradHeight)

  const alpha = 0.12

  let ppi = p0
  for (let i = 1; i <= BANDS; i++) {
    let prevY = Y_SCALE_FACTOR * priceData.scale * (ppi - p0)
    ppi *= 1.1
    let y = Y_SCALE_FACTOR * priceData.scale * (ppi - p0)
  
    var sprite = new PIXI.Sprite(grad)
    sprite.x = -PAST_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX
    sprite.y = prevY
    sprite.anchor.set(0.0, 0.0)
    sprite.alpha = alpha - (i * alpha / BANDS)
    sprite.scale.set((PAST_LENGTH_TICKS + GAME_LENGTH_TICKS) * GRAPH_X_GRANULARITY_PX, (y - prevY) / gradHeight)
    grid.addChild(sprite)
  }

  let pmi = p0
  for (let i = 1; i <= BANDS; i++) {
    let prevY = Y_SCALE_FACTOR * priceData.scale * (pmi - p0)
    pmi *= 0.9
    let y = Y_SCALE_FACTOR * priceData.scale * (pmi - p0)

    var sprite = new PIXI.Sprite(grad)
    sprite.x = -PAST_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX
    sprite.y = y
    sprite.anchor.set(0.0, 0.0)
    sprite.alpha = alpha - (i * alpha / BANDS)
    sprite.scale.set((PAST_LENGTH_TICKS + GAME_LENGTH_TICKS) * GRAPH_X_GRANULARITY_PX, (prevY - y) / gradHeight)
    grid.addChild(sprite)
  }

  let days = new PIXI.Graphics()
  const mul = TICKS_PER_DAY * GRAPH_X_GRANULARITY_PX
  for (let i = -PAST_LENGTH_DAYS; i <= GAME_LENGTH_DAYS; i++) {
    days.lineStyle(2, i < 0 ? 0x222222 : (i == 0 ? 0x444444 : 0x333333))
        .moveTo(i * mul, Y_SCALE_FACTOR * priceData.scale * (pmi - p0))
        .lineTo(i * mul, Y_SCALE_FACTOR * priceData.scale * (ppi - p0))
  }
  grid.addChild(days)

  return grid
}

function gradientTexture(w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w
  canvas.height = h
  var ctx = canvas.getContext('2d')
  var gradient = ctx.createLinearGradient(0, 0, 0, h)
  gradient.addColorStop(0, '#000000')
  gradient.addColorStop(1, '#ffffff')
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, w, h)
  return PIXI.Texture.fromCanvas(canvas)
}

function createPlayer() {
  let player = new PIXI.Graphics()
  player.alpha = 0.2
  player.lineStyle(4, 0xffffff)
  player.drawCircle(0, 0, 8)
  player.endFill()
  return player
}


// ===== trades =====

function enterTrade(isLong, i, margin) {
  assets.trade = {}
  assets.trade.isLong = isLong
  assets.trade.barOpen = assets.trade.barClose = i
  assets.trade.priceOpen = assets.trade.priceClose = priceData.series[i]
  assets.trade.margin = margin
  assets.trade.current = margin
  assets.funds = assets.funds - margin
  assets.trades.push(assets.trade)
}

function exitTrade(i) {
  if (!assets.trade) {
    return
  }

  recalculateTrade(assets.trade, i)
  updateTrade(assets.trade, GRAPH_X_GRANULARITY_PX * i,
    Y_SCALE_FACTOR * priceData.scale * (priceData.series[i] - priceData.series[0]))

  assets.funds = assets.funds + assets.trade.current
  assets.trade = null
}

function recalculateTrade(trade, i) {
  if (!trade) {
    return
  }
  trade.barClose = i
  trade.priceClose = priceData.series[i]

  // TODO: interpolate estimated price between ticks
  const longValue = trade.margin * trade.priceClose / trade.priceOpen
  if (trade.isLong) {
    trade.current = longValue
  } else {
    // assets.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // assets.margin / assets.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti assets.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    trade.current = 2 * trade.margin - longValue
  }
}

function updateTrade(trade, x, y) {
  const profit = Math.round(trade.current - trade.margin)

  // update label
  if (!trade.label) {
    trade.label = new PIXI.Text('', TEXT_STYLE)
    trade.label.scale.set(1, -1)
    trade.label.anchor.set(0.25, 0.5)
    entities.tradelabels.addChild(trade.label)
  }
  trade.label.position.set(x, trade.isLong ? y + 20 : y - 25)
  trade.label.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE
  trade.label.text
    = (profit < 0 ? '-$' : '+$')
    + Math.abs(profit)
    + (trade.isLong ? '\u25B3' : '\u25BD')

  // update trade line
  if (trade.line) {
    entities.tradelines.removeChild(trade.line)
  }

  const color = profit < 0 ? 0xff0000 : 0x00ff00
  trade.line = new PIXI.Graphics()
  trade.line.lineStyle(5, color, 0.66)
    .moveTo(trade.barOpen * GRAPH_X_GRANULARITY_PX,
      Y_SCALE_FACTOR * priceData.scale * (trade.priceOpen - priceData.series[0]))
    .lineTo(x, y)
  entities.tradelines.addChild(trade.line)
}


// ===== high scores =====

function saveResult(returns, hodl, trades) {
  var tradeList = {
    position: trades.map(t => t.isLong ? 'L' : 'S'),
    barOpen: trades.map(t => t.barOpen),
    barClose: trades.map(t => t.barClose),
    priceOpen: trades.map(t => t.priceOpen),
    priceClose: trades.map(t => t.priceClose)
  }

  var q = '?player=' + encodeURIComponent('' + player)
  q += '&return=' + encodeURIComponent(returns.toFixed(3))
  q += '&hodl=' + encodeURIComponent(hodl.toFixed(3))
  q += '&trades=' + encodeURIComponent(trades.length)
  q += '&start=' + encodeURIComponent(priceData.startTick)
  q += '&stop=' + encodeURIComponent(priceData.stopTick)
  q += '&href=' + encodeURIComponent(window.location.href)
  q += '&tradeList=' + encodeURIComponent(JSON.stringify(tradeList))

  var scr = document.createElement('script')
  scr.src = SHEET_URL + q
  document.body.appendChild(scr)
}

function callback(p) {
  var data = JSON.parse(p)
  if (gameOver && data.result == 'success') {
    data.top.forEach(entry => {
      addScore(false, entry[0], entry[1], entry[3])
    })
    showScores()
  }
}

function addScore(self, player, result, trades) {
  assets.scores.push({
    self: self,
    player: '' + player,
    result: Math.round(result * 1000) / 1000,
    trades: trades
  })
}

function showScores() {
  let text = '<strong>RESULTS</strong>\nfor the same time period\n'
  assets.scores = uniqueSorted(assets.scores, (a, b) => b.result - a.result || a.player.localeCompare(b.player))
  assets.scores.forEach(e => {
    text += '\n'
      + tag(e.self ? 'self' : (e.player == HODL_NAME ? 'hodl' : 'b'),
        e.player.slice(0, 14).padEnd(14, ' ')
        + tag(e.result >= 0 ? 'profit' : 'loss', toPercent(e.result).padStart(8, ' '))
        + tag('tr', (' (' + toTrades(e.trades) + ')').padEnd(14, ' '))
      )
  })
  text += '\n\nPress [SPACE] to restart'
  texts.highscores = text
  updateTexts()
}


// ===== event listeners =====

function listenerResize(event) {
  clearTimeout(arguments.callee.timerId)
  arguments.callee.timerId = setTimeout(function() {
    screenWidth = window.innerWidth
    screenHeight = window.innerHeight
    setupUI(screenWidth, screenHeight)
    if (isGameOverScreen()) {
      zoomOutFull()
    } else if (isMainScreen()) {
      setViewPort(0, 0, OFFSET_X)
    }
    app.renderer.resize(screenWidth, screenHeight)
    window.scrollTo(0, 0)
  }, 250)
}

const listenerFocus = event => {
}

const listenerBlur = event => {
  pauseGame(true)
}

const listenerGlobalTap = event => {
  if (gameOver) {
    setup()
  } else if (!gameStarted) {
    startGame()
  }
}

const listenerKeyDown = event => {
  if (paused) {
    pauseGame(false)
  } else if (event.code ==='KeyP') {
    pauseGame(true)
  }
  if (gameOver) {
    if (event.code === 'Space') {
      setup()
    }
    return
  }
  if (event.code === 'KeyS' || event.code === 'ArrowDown') {
    if (input.long) {
      onNeutral()
    } else {
      onShort()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'KeyL' || event.code === 'ArrowUp') {
    if (input.short) {
      onNeutral()
    } else {
      onLong()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'ArrowLeft') {
    onSpeedDown()
    updateSpeedButtons(true, false)
  } else if (event.code === 'ArrowRight') {
    onSpeedUp()
    updateSpeedButtons(false, true)
  } else if (event.code === 'Space') {
    onNeutral()
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'KeyF') {
    toggleFullScreen()
  }
}

const listenerKeyUp = event => {
  if (event.code === 'ArrowLeft' || event.code === 'ArrowRight') {
    updateSpeedButtons()
  }
}

function addInputListeners() {
  window.addEventListener('blur', listenerBlur, false)
  window.addEventListener('focus', listenerFocus, false)
  window.addEventListener('keydown', listenerKeyDown, false)
  window.addEventListener('keyup', listenerKeyUp, false)
}


// ===== utilities (stateless, pure functions) =====

function getQueryParam(param) {
  var query = window.location.search.substring(1)
  var vars = query.split('&')
  for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=')
      if (decodeURIComponent(pair[0]) == param) {
          return decodeURIComponent(pair[1])
      }
  }
  return null
}

function parseBoolean(b) {
  if (typeof b === 'boolean') {
    return b
  } else if (typeof b === 'string') {
    return b.toLowerCase() === 'true'
  } else if (typeof b === 'number') {
    return b !== 0 && !isNaN(b)
  } else {
    return false
  }
}

function uniqueSorted(arr, cmp) {
  return arr.sort(cmp).filter((e, i, arr) => !i || cmp.apply(null, [e, arr[i - 1]]) != 0)
}

function tag(tag, string) {
  return (tag ? '<' + tag + '>' : '')
    + string
    + (tag ? '</' + tag + '>' : '')
}

function toPercent(num) {
  return (num * 100).toFixed(1) + '%'
}

function toAbsPercent(num) {
  return toPercent(Math.abs(num))
}

function toTrades(num) {
  return num === 0 ? 'no trades' :
    num === 1 ? '1 trade' :
    num + ' trades'
}

function parsePriceData(data, ticks) {
  const chunks = Math.floor(data.values.length / ticks)
  const fromIndex = ticks * (Math.floor(Math.random() * (chunks - 1)) + 1)
  const series = data.values.slice(fromIndex, fromIndex + ticks + 1)
  const pastSeries = data.values.slice(fromIndex - PAST_LENGTH_TICKS, fromIndex + 1)
  const first = series[0]
  return {
    series: series,
    pastSeries: pastSeries,
    min: Math.min(...series),
    max: Math.max(...series),
    scale: 1 / (2 * (first * 1.1 * 1.1 - first * 0.9 * 0.9)),
    startTick: fromIndex,
    stopTick: fromIndex + ticks,
  }
}

function isMainScreen() {
  return !gameStarted && !gameOver
}

function isGameRunning() {
  return gameStarted && !gameOver
}

function isGameOverScreen() {
  return !gameStarted && gameOver
}

// ===== text styles =====

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 28,
  fill: 0xffffff,
  align: 'center',
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_MULTI_STYLE = {
  'default': {
    fontFamily: '"B612 Mono", monospace',
    fontSize: 20,
    fill: 0xcccccc,
    align: 'center',
    dropShadow: true,
    dropShadowAlpha: 0.6,
    dropShadowBlur: 10,
    dropShadowDistance: 3,
  },
  'b': {
    fontWeight: 'bold',
  },
  'strong': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'title': {
    fontSize: 28,
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'self': {
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'hodl': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'profit': {
    fontWeight: 'bold',
    fill: 0x00ff00,
  },
  'loss': {
    fontWeight: 'bold',
    fill: 0xff0000,
  },
  'tr': {
    fill: 0x666666,
  },
};

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

    </script>
  </body>
</html>
