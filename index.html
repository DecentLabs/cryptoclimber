<!doctype html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130030503-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-130030503-3');
    </script>

    <meta charset="utf-8">
    <style>* {padding: 0; margin: 0}</style>

    <title>Crypto Climber</title>
    <meta property="og:title" content="Crypto Climber" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://cryptoclimber.decent.org/" />
    <meta property="og:image" content="https://cryptoclimber.decent.org/og.png" />
    <meta property="og:description" content="Fun little game about bitcoin trading" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
    <script src="pixi-multistyle-text/0.6.0/pixi-multistyle-text.umd.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  </head>
  <body>
    <script>


// ===== constants =====

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = parseInt(getQueryParam('days'), 10) || 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY

const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const OFFSET_X = 0.25
const SMOOTH_FACTOR_Y = 50

const MARGIN = 15
const BUTTON_WIDTH = 160
const BUTTON_HEIGHT = 80

const SHOW_PRICE = false
const SHOW_DEBUG = false

const MIN_SPEED = 12 // smaller is faster
const MAX_SPEED = 4 // smaller is faster
const WARP_SPEED_DELTA = (MIN_SPEED - MAX_SPEED) / 30

const MIN_ZOOM = 0.75
const MAX_ZOOM = 1.25
const WARP_ZOOM_DELTA = (MAX_ZOOM - MIN_ZOOM) / 30

const INTRO =
  'How good are you at trading' +
  '\na ' + GAME_LENGTH_DAYS + ' day sample of' +
  '\nhistorical Bitcoin prices?' +
  '<strong>' +
  '\n\nPress [UP] to go LONG' +
  '\nPress [DOWN] to sell SHORT' +
  '\nPress [SPACE] to close position ' +
  '</strong>' +
  '\n\nHold [SHIFT] for warp speed' +
  '\n\n<strong>Press [SPACE] to start!</strong>'

const HODL_NAME = 'Buy and hold'

const SHEET_URL = 'https://script.google.com/macros/s/AKfycbyDTk5pYHGjgHartXZZX876CZbKYa_kKljZDEOJ1dylwVSn1Mk/exec'


// ===== global variables =====

const SCREEN_WIDTH = window.innerWidth
const SCREEN_HEIGHT = window.innerHeight

var SPEED = MIN_SPEED
var ZOOM = MAX_ZOOM

var ENTITIES = defaultEntities()

var ASSETS = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
  scores: [],
}

var priceData
var player = getQueryParam('player')


let viewPortX = 0
let viewPortY = 0


var time = 0
var tick = -1

var gameOver = false
var gameStarted = false

const INPUT = {
  short: false,
  long: false,
  warp: false,
}


// ===== startup code =====

const CONF = {
  width: window.innerWidth,
  height: window.innerHeight,
  antialias: true,
  transparent: false,
  resolution: window.devicePixelRatio,
};

const app = new PIXI.Application(CONF);


// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.autoResize = true;
app.renderer.resize(SCREEN_WIDTH, SCREEN_HEIGHT);

document.body.appendChild(app.view);

PIXI.loader
.add('prices', 'btc1h.json')
.load(() => {
  // TODO: load font concurrently with resources
  WebFont.load({
    google: {
      families: ['B612 Mono']
    },
    active: setup
  })
});


function defaultEntities() {
  return {
    gamespace: null,
    messages: {
      iteration: null,
      funds: null,
      summary: null,
      highscores: null,
      price: null,
      debug: null,
    },
    logos: null,
    lines: [],
    player: null,
  }
}


// =====  =====


function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  gameOver = false
  gameStarted = false

  time = 0
  tick = -1
  SPEED = MIN_SPEED
  ZOOM = MAX_ZOOM

  ENTITIES = defaultEntities()
  ASSETS.funds = INIT_FUNDS
  ASSETS.trades = []
  ASSETS.scores = []
  ASSETS.trade = null

  priceData = parsePriceData(PIXI.loader.resources.prices.data, GAME_LENGTH_TICKS)
  GAME_WIDTH = (priceData.series.length - 1) * GRAPH_X_GRANULARITY_PX
  GAME_HEIGHT = (priceData.max - priceData.min) * priceData.scale

  ENTITIES.gamespace = new PIXI.Container()
  ENTITIES.gamespace.addChild(createGrid())

  let {graph, lines} = createGraph()
  ENTITIES.gamespace.addChild(graph)
  ENTITIES.lines = lines

  ENTITIES.player = createPlayer()
  ENTITIES.gamespace.addChild(ENTITIES.player)

  app.stage.addChild(ENTITIES.gamespace)

  let {messagesContainer, messages} = createMessages(SCREEN_WIDTH, SCREEN_HEIGHT, MARGIN)
  app.stage.addChild(messagesContainer)
  ENTITIES.messages = messages

  ENTITIES.logos = createLogos(SCREEN_WIDTH, SCREEN_HEIGHT, MARGIN)
  app.stage.addChild(ENTITIES.logos)

  ENTITIES.smallLogo = createSmallLogo(SCREEN_WIDTH, SCREEN_HEIGHT, MARGIN)
  app.stage.addChild(ENTITIES.smallLogo)

  ENTITIES.longButton = createButton("\u25B3 Long ",
    SCREEN_WIDTH - BUTTON_WIDTH - MARGIN, SCREEN_HEIGHT - 3 * BUTTON_HEIGHT - 5 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT,
    (pressed) => {
      if (pressed) {
        onLong()
      }
    })

  ENTITIES.neutralButton = createButton("Neutral",
    SCREEN_WIDTH - BUTTON_WIDTH - MARGIN, SCREEN_HEIGHT - 2 * BUTTON_HEIGHT - 3 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT,
    (pressed) => {
      if (pressed) {
        onNeutral()
      }
    })

  ENTITIES.shortButton = createButton("\u25BD Short",
    SCREEN_WIDTH - BUTTON_WIDTH - MARGIN, SCREEN_HEIGHT - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT,
    (pressed) => {
      if (pressed) {
        onShort()
      }
    })

  ENTITIES.warpButton = createButton("\u232A\u232AWarp",
    MARGIN, SCREEN_HEIGHT - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, onWarp)

  onNeutral()
  showControls(false)

  app.stage.addChild(ENTITIES.longButton)
  app.stage.addChild(ENTITIES.neutralButton)
  app.stage.addChild(ENTITIES.shortButton)
  app.stage.addChild(ENTITIES.warpButton)

  setViewPort(0, 0, OFFSET_X)
  addInputListeners()
  app.ticker.add(update)
}


function startGame() {
  ENTITIES.messages.summary.text = ''
  ENTITIES.messages.highscores.text = ''
  ENTITIES.logos.visible = false
  ENTITIES.smallLogo.visible = true
  showControls(true)
  gameStarted = true
}

function onWarp(warpState) {
  INPUT.warp = warpState
  ENTITIES.warpButton.tint = warpState ? 0xffff00 : 0xffffff
}

function onLong() {
  INPUT.short = false
  INPUT.long = true
  ENTITIES.longButton.tint = 0xff00ff
  ENTITIES.neutralButton.tint = 0xffffff
  ENTITIES.shortButton.tint = 0xffffff
}

function onShort() {
  INPUT.short = true
  INPUT.long = false
  ENTITIES.longButton.tint = 0xffffff
  ENTITIES.neutralButton.tint = 0xffffff
  ENTITIES.shortButton.tint = 0xff00ff
}

function onNeutral() {
  INPUT.long = false
  INPUT.short = false
  ENTITIES.longButton.tint = 0xffffff
  ENTITIES.neutralButton.tint = 0xff00ff
  ENTITIES.shortButton.tint = 0xffffff
}


function showControls(show) {
  ENTITIES.longButton.visible =
  ENTITIES.neutralButton.visible =
  ENTITIES.shortButton.visible =
  ENTITIES.warpButton.visible =
  show
}



function setViewPort(x, y, xOffset) {
  viewPortX = x
  viewPortY = y
  ENTITIES.gamespace.scale.x = ZOOM
  ENTITIES.gamespace.scale.y = -ZOOM
  ENTITIES.gamespace.position.x = -(x * ZOOM - SCREEN_WIDTH / 2 - (SCREEN_WIDTH * xOffset))
  ENTITIES.gamespace.position.y = -(-y * ZOOM - SCREEN_HEIGHT / 2)
}

function movePlayer(x, y) {
  ENTITIES.player.x = x
  ENTITIES.player.y = y
}




function update(dt) {
  if (!gameStarted) {
    return
  }

  if (INPUT.warp) {
    SPEED = Math.max(MAX_SPEED, SPEED - WARP_SPEED_DELTA)
    ZOOM = Math.max(MIN_ZOOM, ZOOM - WARP_ZOOM_DELTA)
  } else {
    SPEED = Math.min(MIN_SPEED, SPEED + WARP_SPEED_DELTA)
    ZOOM = Math.min(MAX_ZOOM, ZOOM + WARP_ZOOM_DELTA)
  }

  time += dt / SPEED
  var i = Math.floor(time)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      gameStarted = false
      showGameOver()
    }
    return
  }

  if (tick >= 0) {
    x = time * GRAPH_X_GRANULARITY_PX
    y = priceData.scale * ((priceData.series[tick] - priceData.series[0])
      + (time - tick) * (priceData.series[tick + 1] - priceData.series[tick]))

    setViewPort(x, (viewPortY + (y - viewPortY) / SMOOTH_FACTOR_Y), OFFSET_X)
    movePlayer(x, y)
    updateTrade(i)
  }

  if (i > tick) {
    tick = i

    const currentPrice = priceData.series[i]
    priceData.runningMin = Math.min(priceData.runningMin, currentPrice)
    priceData.runningMax = Math.max(priceData.runningMax, currentPrice)

    handleInput(i)

    ENTITIES.lines[i].visible = true

    updatePlayer()
    updateMessages(i)
  }
}

function handleInput(i) {
  if (INPUT.long && !INPUT.short) {
    // LONG
    if (ASSETS.trade) {
      if (ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(true, i, ASSETS.funds)
  } else if (!INPUT.long && INPUT.short) {
    // SHORT
    if (ASSETS.trade) {
      if (!ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(false, i, ASSETS.funds)
  } else {
    // NEUTRAL
    if (ASSETS.trade) {
      exitTrade()
    }
  }
}

function updatePlayer() {
  ENTITIES.player.alpha = ASSETS.trade ? 0.5 : 0.2
}

function updateMessages(i) {
  ENTITIES.messages.summary.text = ''

  ENTITIES.messages.iteration.text = 'Day ' + (Math.floor(i / TICKS_PER_DAY) + 1) + ' of ' + GAME_LENGTH_DAYS
  var equity = ASSETS.funds + (ASSETS.trade ? ASSETS.trade.current : 0)

  ENTITIES.messages.funds.text = 'Equity $' + Math.round(equity)
  if (SHOW_PRICE) {
    ENTITIES.messages.price.text = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    ENTITIES.messages.debug.text =
      'inputs:' + (INPUT.short?'S':' ') + (INPUT.long?'L':' ') + (INPUT.warp?'W':' ')
      + ' trade:' + (ASSETS.trade ? (ASSETS.trade.isLong ? 'L' : 'S') : 'N')
      + ' speed:' + (SPEED.toFixed(2)) + ' zoom:' + (ZOOM.toFixed(2))
      + ' x:' + viewPortX.toFixed(2) + ' y:' + viewPortY.toFixed(2)
      + ' tick:' + tick
  }
}

function showGameOver() {
  onNeutral()
  onWarp(false)
  showControls(false)
  if (ASSETS.trade) {
    exitTrade()
  }
  updateMessages(GAME_LENGTH_TICKS - 1)

  const profit = ASSETS.funds - INIT_FUNDS
  const returns = profit / INIT_FUNDS
  const hodlReturns = priceData.series[GAME_LENGTH_TICKS] / priceData.series[0] - 1
  const beatsHodl = returns > hodlReturns

  ZOOM = SCREEN_WIDTH / GAME_WIDTH
  setViewPort(GAME_WIDTH / 2, 0, 0)

  setTimeout(() => {
    if (!player) {
      player = window.prompt('Nick name?') || 'anonymous';
    }
    addScore(true, player, returns, ASSETS.trades.length)
    addScore(false, HODL_NAME, hodlReturns, 1)
    showScores()
    saveResult(returns, hodlReturns, ASSETS.trades.length)
  })
}


// ===== 'create' methods =====

function createGraph() {
  const p0 = priceData.series[0]
  let graph = new PIXI.Container()
  let lines = []

  for (let i = 0; i < priceData.series.length - 1; i++) {
    let line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(2, 0xffffff)
        .moveTo(GRAPH_X_GRANULARITY_PX * i, priceData.scale * (priceData.series[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 1), priceData.scale * (priceData.series[i + 1] - p0))
    line.visible = false
    lines.push(line)
    graph.addChild(line)
  }

  const past = priceData.pastSeries.length
  for (let i = 0; i < past; i++) {
    let line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(2, 0x666666)
        .moveTo(GRAPH_X_GRANULARITY_PX * (i + 1 - past) , priceData.scale * (priceData.pastSeries[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 2 - past), priceData.scale * (priceData.pastSeries[i + 1] - p0))
    graph.addChild(line)
  }

  return {graph, lines}
}

function createButton(text, x, y, w, h, callback) {
  const g = new PIXI.Graphics()

  const txt = new PIXI.Text(text, TEXT_STYLE)
  txt.x = (w - txt.width) / 2
  txt.y = (h - txt.height) / 2
  g.addChild(txt)

  g.lineStyle(2, 0xffffff, 1);
  g.beginFill(0xffffff, 0.25);
  g.drawRoundedRect(0, 0, w, h, 15);
  g.endFill();

  g.x = x
  g.y = y

  g.buttonMode = true
  g.interactive = true
  g.buttonStates = new Set()
  g.buttonLastState = false

  // hacks to ensure reasonable multitouch behavior
  const f = e => {
    const release = e.type == 'pointerup' || e.type == 'pointerupoutside' || e.type =='pointercancel'
    const pressing = !release && app.renderer.plugins.interaction.hitTest(e.data.global, g) && e.data.buttons == 1
    const id = e.data.pointerId
    if (pressing) {
      g.buttonStates.add(id)
    } else {
      g.buttonStates.delete(id)
    }
    // console.log(text, pressing, g.buttonStates, e.type, id)
    const state = g.buttonStates.size != 0
    if (g.buttonLastState != state) {
      g.buttonLastState = state
      callback(state)
    } 
  }
  app.stage.interactive = true
  app.stage.on('pointermove', f)
  app.stage.on('pointerdown', f)
  app.stage.on('pointerup', f)
  app.stage.on('pointerupoutside', f)
  app.stage.on('pointercancel', f)

  return g
}

function createMessages(width, height, margin) {
  let messagesContainer = new PIXI.Container()
  let messages = {}

  const ROW_HEIGHT = 30
  var x = margin
  var y = margin

  messages.iteration = new PIXI.Text('', TEXT_STYLE)
  messages.iteration.position.set(x, y)
  messagesContainer.addChild(messages.iteration)
  y += ROW_HEIGHT

  messages.funds = new PIXI.Text('', TEXT_STYLE)
  messages.funds.position.set(x, y)
  messagesContainer.addChild(messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    messages.price = new PIXI.Text('', TEXT_STYLE)
    messages.price.position.set(x, y)
    messagesContainer.addChild(messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    messages.debug = new PIXI.Text('', TEXT_STYLE)
    messages.debug.position.set(x, y)
    messagesContainer.addChild(messages.debug)
    y += ROW_HEIGHT
  }

  messages.summary = new MultiStyleText(INTRO, TEXT_MULTI_STYLE)
  messages.summary.position.set(width / 2, height / 2 + margin)
  messages.summary.anchor.set(0.5, 0.0)
  messagesContainer.addChild(messages.summary)

  messages.highscores = new MultiStyleText('', TEXT_MULTI_STYLE)
  messages.highscores.position.set(width / 2, height / 2)
  messages.highscores.anchor.set(0.5, 0.5)
  messagesContainer.addChild(messages.highscores)

  return {messagesContainer, messages}
}

function createLogos(width, height, margin) {
  let logoContainer = new PIXI.Container()

  let logo = new PIXI.Sprite.from('logo_vertical.png')
  logo.position.set(width / 2, height / 2 - margin)
  logo.anchor.set(0.5, 1.0)
  logoContainer.addChild(logo)

  let createdBy = new PIXI.Sprite.from('created.png')
  createdBy.position.set(margin, height - margin)
  createdBy.anchor.set(0.0, 1.0)
  createdBy.scale.set(0.5)
  createdBy.interactive = true
  createdBy.buttonMode = true
  createdBy.on('click', () => { window.location.href = 'https://decent.org/' })
  logoContainer.addChild(createdBy)

  return logoContainer
}

function createSmallLogo(width, height, margin) {
  let logo = new PIXI.Sprite.from('logo_small.png')
  logo.position.set(width - margin, margin)
  logo.anchor.set(1.0, 0.0)
  logo.scale.set(0.5)
  logo.visible = false
  return logo
}

function createGrid() {
  let grid = new PIXI.Container()

  const p0 = priceData.series[0]
  const margin = SCREEN_WIDTH * ZOOM

  const gradHeight = 256
  const grad = gradientTexture(1, gradHeight)

  const bands = 20
  const alpha = 0.12

  let ppi = p0
  //for (i = 1; ppi < priceData.max; i++) {
  for (let i = 1; i <= bands; i++) {
    let prevY = priceData.scale * (ppi - p0)
    ppi *= 1.1
    let y = priceData.scale * (ppi - p0)
  
    var sprite = new PIXI.Sprite(grad)
    sprite.x = -margin
    sprite.y = prevY
    sprite.alpha = alpha - (i * alpha / bands)
    sprite.scale.set(GAME_WIDTH + (2 * margin), (y - prevY) / gradHeight)
    grid.addChild(sprite)
  }

  let pmi = p0
  //for (i = 1; pmi > priceData.min; i++) {
  for (let i = 1; i <= bands; i++) {
    let prevY = priceData.scale * (pmi - p0)
    pmi *= 0.9
    let y = priceData.scale * (pmi - p0)

    var sprite = new PIXI.Sprite(grad)
    sprite.x = -margin
    sprite.y = y
    sprite.alpha = alpha - (i * alpha / bands)
    sprite.scale.set(GAME_WIDTH + (2 * margin), (prevY - y) / gradHeight)
    grid.addChild(sprite)
  }

  let days = new PIXI.Graphics()
  const mul = 24 * GRAPH_X_GRANULARITY_PX
  for (let i = -priceData.pastSeries.length; i <= GAME_LENGTH_DAYS; i++) {
    days.lineStyle(2, i < 0 ? 0x222222 : 0x333333)
        .moveTo(i * mul, -2 * SCREEN_HEIGHT)
        .lineTo(i * mul, 2 * SCREEN_HEIGHT)
  }
  grid.addChild(days)

  return grid
}

function gradientTexture(w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w
  canvas.height = h
  var ctx = canvas.getContext('2d')
  var gradient = ctx.createLinearGradient(0, 0, 0, h)
  gradient.addColorStop(0, '#000000')
  gradient.addColorStop(1, '#ffffff')
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, w, h)
  return PIXI.Texture.fromCanvas(canvas)
}

function createPlayer() {
  let player = new PIXI.Graphics()
  player.alpha = 0.2
  player.lineStyle(4, 0xffffff)
  player.drawCircle(0, 0, 8)
  player.endFill()
  return player
}


// ===== trades =====

function enterTrade(isLong, i, margin) {
  ASSETS.trade = {}
  ASSETS.trade.barOpen = ASSETS.trade.barClose = i
  ASSETS.trade.isLong = isLong
  ASSETS.trade.strikePrice = priceData.series[i]
  ASSETS.trade.margin = margin
  ASSETS.trade.current = margin
  ASSETS.funds = ASSETS.funds - margin
  ASSETS.trades.push(ASSETS.trade)
}

function exitTrade() {
  ASSETS.funds = ASSETS.funds + ASSETS.trade.current
  ASSETS.trade = null
}

function updateTrade(i) {
  if (!ASSETS.trade) {
    return
  }
  ASSETS.trade.barClose = i

  // TODO: interpolate estimated price between ticks
  const longValue = ASSETS.trade.margin / ASSETS.trade.strikePrice * priceData.series[i]
  if (ASSETS.trade.isLong) {
    ASSETS.trade.current = longValue
  } else {
    // ASSETS.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // ASSETS.margin / ASSETS.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti ASSETS.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    ASSETS.trade.current = 2 * ASSETS.trade.margin - longValue
  }

  const profit = Math.round(ASSETS.trade.current - ASSETS.trade.margin)

  // update label
  if (!ASSETS.trade.label) {
    ASSETS.trade.label = new PIXI.Text('', TEXT_STYLE)
    ASSETS.trade.label.scale.set(1 / ZOOM, -1 / ZOOM)
    ASSETS.trade.label.zOrder = -ASSETS.trades.length
    ENTITIES.gamespace.addChild(ASSETS.trade.label)
  }
  ASSETS.trade.label.position.set(x - 15, y + (ASSETS.trade.isLong ? -10 : 20))

  ASSETS.trade.label.text = (profit < 0 ? ' -$' : ' +$') + Math.abs(profit)
  ASSETS.trade.label.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE

  // update trade line
  if (ASSETS.trade.line) {
    ENTITIES.gamespace.removeChild(ASSETS.trade.line)
  }

  const color = profit < 0 ? 0xff0000 : 0x00ff00
  ASSETS.trade.line = new PIXI.Graphics()
  const a = ASSETS.trade.barOpen
  ASSETS.trade.line.lineStyle(5, color, 0.66)
    .moveTo(a * GRAPH_X_GRANULARITY_PX, priceData.scale * (priceData.series[a] - priceData.series[0]))
    .lineTo(x, y)
  ENTITIES.gamespace.addChild(ASSETS.trade.line)
}


// ===== high scores =====

function saveResult(returns, hodl, trades) {
  var q = '?player=' + encodeURIComponent(player)
  q += '&return=' + encodeURIComponent(returns.toFixed(3))
  q += '&hodl=' + encodeURIComponent(hodl.toFixed(3))
  q += '&trades=' + encodeURIComponent(trades)
  q += '&start=' + encodeURIComponent(priceData.startTick)
  q += '&stop=' + encodeURIComponent(priceData.stopTick)
  var scr = document.createElement('script')
  scr.src = SHEET_URL + q
  document.body.appendChild(scr)
}

function callback(p) {
  var data = JSON.parse(p)
  if (gameOver && data.result == 'success') {
    data.top.forEach(entry => {
      addScore(false, entry[0], entry[1], entry[3])
    })
    showScores()
  }
}

function addScore(self, player, result, trades) {
  ASSETS.scores.push({
    self: self,
    player: player,
    result: Math.round(result * 1000) / 1000,
    trades: trades
  })
}

function showScores() {
  let text = '<strong>RESULTS</strong>\nfor the same time period\n'
  ASSETS.scores = uniqueSorted(ASSETS.scores, (a, b) => b.result - a.result || a.player.localeCompare(b.player))
  ASSETS.scores.forEach(e => {
    text += '\n'
      + tag(e.self ? 'self' : (e.player == HODL_NAME ? 'hodl' : 'b'),
        e.player.slice(0, 14).padEnd(14, ' ')
        + tag(e.result >= 0 ? 'profit' : 'loss', toPercent(e.result).padStart(8, ' '))
        + tag('tr', (' (' + toTrades(e.trades) + ')').padEnd(14, ' '))
      )
  })
  text += '\n\nPress [SPACE] to restart'
  ENTITIES.messages.highscores.text = text
}


// ===== event listeners =====

const listenerBlur = event => {
  onNeutral()
  onWarp(false)
}

const listenerTouchStart = event => {
  if (gameOver) {
    setup()
    return
  }
  if (!gameStarted) {
    startGame()
  }
}

const listenerKeyDown = event => {
  if (gameOver) {
    if (event.code === 'Space') {
      setup()
    }
    return
  }
  if (event.code === 'KeyS' || event.code === 'ArrowDown') {
    if (INPUT.long) {
      onNeutral()
    } else {
      onShort()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'KeyL' || event.code === 'ArrowUp') {
    if (INPUT.short) {
      onNeutral()
    } else {
      onLong()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'Space') {
    onNeutral()
    if (!gameStarted) {
      startGame()
    }
  }
  if (event.key === 'Shift') {
    onWarp(true)
  }
}

const listenerKeyUp = event => {
  if (event.key === 'Shift') {
    onWarp(false)
  }
}

function addInputListeners() {
  window.addEventListener('blur', listenerBlur, false)
  window.addEventListener('touchstart', listenerTouchStart, false)
  window.addEventListener('keydown', listenerKeyDown, false)
  window.addEventListener('keyup', listenerKeyUp, false)
}


// ===== utilities (stateless, pure functions) =====

function getQueryParam(param) {
  var query = window.location.search.substring(1)
  var vars = query.split('&')
  for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=')
      if (decodeURIComponent(pair[0]) == param) {
          return decodeURIComponent(pair[1])
      }
  }
  return null
}

function uniqueSorted(arr, cmp) {
  return arr.sort(cmp).filter((e, i, arr) => !i || cmp.apply(null, [e, arr[i - 1]]) != 0)
}

function tag(tag, string) {
  return (tag ? '<' + tag + '>' : '')
    + string
    + (tag ? '</' + tag + '>' : '')
}

function toPercent(num) {
  return (num * 100).toFixed(1) + '%'
}

function toAbsPercent(num) {
  return toPercent(Math.abs(num))
}

function toTrades(num) {
  return num === 0 ? 'no trades' :
    num === 1 ? '1 trade' :
    num + ' trades'
}

function parsePriceData(data, ticks) {
  const chunks = Math.floor(data.values.length / ticks)
  const fromIndex = ticks * (Math.floor(Math.random() * (chunks - 1)) + 1)
  const series = data.values.slice(fromIndex, fromIndex + ticks + 1)
  const pastSeries = data.values.slice(fromIndex - ticks, fromIndex + 1)
  const first = series[0]
  return {
    series: series,
    pastSeries: pastSeries,
    min: Math.min(...series),
    max: Math.max(...series),
    runningMin: first,
    runningMax: first,
    scale: SCREEN_HEIGHT / 2 / (first * 1.1 * 1.1 - first * 0.9 * 0.9),
    startTick: fromIndex,
    stopTick: fromIndex + ticks,
  }
}


// ===== text styles =====

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 28,
  fill: 0xffffff,
  align: 'center',
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_MULTI_STYLE = {
  'default': {
    fontFamily: '"B612 Mono", monospace',
    fontSize: 20,
    fill: 0xcccccc,
    align: 'center',
    dropShadow: true,
    dropShadowAlpha: 0.6,
    dropShadowBlur: 10,
    dropShadowDistance: 3,
  },
  'b': {
    fontWeight: 'bold',
  },
  'strong': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'title': {
    fontSize: 28,
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'self': {
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'hodl': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'profit': {
    fontWeight: 'bold',
    fill: 0x00ff00,
  },
  'loss': {
    fontWeight: 'bold',
    fill: 0xff0000,
  },
  'tr': {
    fill: 0x666666,
  },
};

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

    </script>
  </body>
</html>
