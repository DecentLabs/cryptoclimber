<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Crypto Climber</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
    <style>* {padding: 0; margin: 0}</style>
  </head>
  <body>
    <script>

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY
const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const SPEED = 10 // smaller is faster
const SHOW_PRICE = true
const SHOW_DEBUG = true
const BASELINE_COLOR = 0x666666

const INTRO = 'Crypto Climber\n\n' +
  'You\'ll get a random 30 day sample of Bitcoin\'s price history.\nCan you  guess which way it will move?' +
  '\n\nHold [L] if you think the price goes up to open a long position' +
  '\nHold [S] if you think the price goes down to short sell Bitcoin' +
  '\n\nPress any key to start!'

const CONF = {
  width: 1024,
  height: 768,
  antialias: true,
  transparent: false,
  resolution: 1
};

const app = new PIXI.Application(CONF);
const W = window.innerWidth
const H = window.innerHeight
// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.autoResize = true;
app.renderer.resize(W, H);

document.body.appendChild(app.view);

PIXI.loader
  .add('bg', 'bg_tile.jpg')
  .add('prices', 'btc1h.json')
  .load(setup);

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 18,
  fill: 0xcccccc,
});

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
});


function defaultEntities() {
  return {
    background: null,
    player: null,
    messages: {
      iteration: null,
      funds: null,
      position: null,
      summary: null,
      price: null,
      debug: null,
    },
    lines: [],
    baselines: null,
  }
}

var ENTITIES = defaultEntities()

var ASSETS = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
}

var priceData

function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  time = 0
  ENTITIES = defaultEntities()
  ASSETS.funds = INIT_FUNDS
  priceData = parsePriceData(PIXI.loader.resources.prices.data)

  addInputListeners()
  setupBackground()
  setupBaseLines()
  setupPlayer()
  setupMessages()
  app.ticker.add(update)
}

function setupPlayer() {
  ENTITIES.player = new PIXI.Graphics()
  ENTITIES.player.lineStyle(2, 0xFF00FF)
  ENTITIES.player.drawCircle(W/2, H/2, 4)
  ENTITIES.player.endFill()
  app.stage.addChild(ENTITIES.player)
}

function setupBackground() {
  ENTITIES.background = new PIXI.Container()
  const bgTexture = PIXI.loader.resources.bg.texture
  const w = bgTexture.width
  const h = bgTexture.height
  for (let i = -w; i < W; i += w) {
    for (let j = -h; j < H; j += h) {
      let bgSprite = new PIXI.Sprite(bgTexture)
      bgSprite.position.set(i, j)
      bgSprite.alpha = 0.5
      ENTITIES.background.addChild(bgSprite)
    }
  }
  app.stage.addChild(ENTITIES.background)
}

function setupMessages() {
  messagesContainer = new PIXI.Container()

  var x = 4
  var y = 4
  const ROW_HEIGHT = 20
  ENTITIES.messages.iteration = new PIXI.Text('day: 1 / ' + GAME_LENGTH_DAYS, TEXT_STYLE)
  ENTITIES.messages.iteration.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.iteration)
  y += ROW_HEIGHT

  ENTITIES.messages.funds = new PIXI.Text('funds: $' + ASSETS.funds, TEXT_STYLE)
  ENTITIES.messages.funds.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    ENTITIES.messages.price = new PIXI.Text('price: $', TEXT_STYLE)
    ENTITIES.messages.price.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    ENTITIES.messages.debug = new PIXI.Text('', TEXT_STYLE)
    ENTITIES.messages.debug.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.debug)
    y += ROW_HEIGHT
  }

  ENTITIES.messages.position = new PIXI.Text('', TEXT_STYLE)
  ENTITIES.messages.position.position.set(W/2 + 32, H/2 - 12)
  messagesContainer.addChild(ENTITIES.messages.position)

  ENTITIES.messages.summary = new PIXI.Text(INTRO, TEXT_STYLE)
  ENTITIES.messages.summary.position.set(W/2, 64)
  ENTITIES.messages.summary.anchor.set(0.5, 0)
  messagesContainer.addChild(ENTITIES.messages.summary)

  app.stage.addChild(messagesContainer)
}

var time = 0

var diff
var gameOver = false
var gameStarted = false

const INPUT = {
  short: false,
  long: false,
}

function positionToColor(diff) {
  return 0xffffff
}
function positionToThickness() {
  return ASSETS.trade ? 4 : 1
}

function update(dt) {
  if (!gameStarted) {
    return
  }
  dt2 = dt / SPEED
  time += dt2
  var i = Math.min(Math.floor(time), GAME_LENGTH_TICKS)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      showGameOver(i)
    }
    return
  }
  if (ENTITIES.lines.length === i) {
    handleInput(i)

    let line = new PIXI.Graphics()
    line.position.set(W/2, H/2)

    const currentPrice = priceData.series[i]

    priceData.runningMin = Math.min(priceData.runningMin, currentPrice)
    priceData.runningMax = Math.max(priceData.runningMax, currentPrice)

    diff = priceData.series[i + 1] - currentPrice
    line.lineStyle(positionToThickness(), positionToColor(diff))
        .moveTo(0, 0)
        .lineTo(GRAPH_X_GRANULARITY_PX, -priceData.scale * diff)

    ENTITIES.lines.push(line)
    app.stage.addChild(line)

    updateTrade(i)

    updateMessages(i)
  }
  ENTITIES.lines.forEach(line => {
    line.x -= GRAPH_X_GRANULARITY_PX * dt2
    line.y += priceData.scale * diff * dt2
  })
  ENTITIES.baselines.y += priceData.scale * diff * dt2
}

function handleInput(i) {
  if (INPUT.long && !INPUT.short) {
    // LONG
    if (ASSETS.trade) {
      if (ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(true, i, ASSETS.funds)
  } else if (!INPUT.long && INPUT.short) {
    // SHORT
    if (ASSETS.trade) {
      if (!ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(false, i, ASSETS.funds)
  } else {
    // NEUTRAL
    if (ASSETS.trade) {
      exitTrade()
    }
  }
}

function updateMessages(i) {
  ENTITIES.messages.summary.text = ''
  if (ASSETS.trade) {
    const profit = Math.round(ASSETS.trade.current - ASSETS.trade.margin)
    ENTITIES.messages.position.text = //(ASSETS.trade.isLong ? 'LONG' : 'SHORT') +
      (profit < 0 ? ' -$' : ' +$') + Math.abs(profit)
    ENTITIES.messages.position.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE
  } else {
    ENTITIES.messages.position.text = ''
  }

  ENTITIES.messages.iteration.text = 'day: ' + Math.floor(i / TICKS_PER_DAY) + ' / ' + GAME_LENGTH_DAYS
  var equity = ASSETS.funds + (ASSETS.trade ? ASSETS.trade.current : 0)

  ENTITIES.messages.funds.text = 'net worth: $' + Math.round(equity)
  if (SHOW_PRICE) {
    ENTITIES.messages.price.text = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    ENTITIES.messages.debug.text =
      'inputs: ' + (INPUT.short?'S':' ') + (INPUT.long?'L':' ') +
      ' trade: ' + (ASSETS.trade ? (ASSETS.trade.isLong ? 'L' : 'S') : '-')
  }
}

function showGameOver(i) {
  ENTITIES.lines.forEach(line => {
    line.x += H/2 - 16
  })
  ENTITIES.player.x += H/2 - 16
  if (ASSETS.trade) {
    exitTrade()
  }
  ENTITIES.messages.iteration.text = 'day: ' + Math.floor(i / TICKS_PER_DAY) + ' / ' + GAME_LENGTH_DAYS
  ENTITIES.messages.funds.text = 'net worth: $' + Math.round(ASSETS.funds)
  if (SHOW_PRICE) {
    ENTITIES.messages.price.text = ''
  }
  ENTITIES.messages.position.text = ''
  if (SHOW_DEBUG) {
    ENTITIES.messages.debug.text = ''
  }

  const result = ASSETS.funds - INIT_FUNDS
  const resultPercent = (result / INIT_FUNDS * 100).toFixed(1)
  const hodlPercent = ((priceData.series[i] / priceData.series[0] - 1) * 100).toFixed(1)
  var summary = result >= 0 ?
      ('YAY! You made a return: ' + resultPercent + '%') :
      ('ONOES! You lost ' + resultPercent + '% of your investment')
  summary += '\nBuy and hold: ' + hodlPercent + '%'
  summary += '\nNumber of trades: ' + ASSETS.trades.length
  // summary += '\nPeriod: ' + priceData.from + ' - ' + priceData.to
  summary += '\nPrice range: $' + priceData.min + ' - $' + priceData.max
  summary += '\n\nPress almost any key to reset.'
  ENTITIES.messages.summary.text = summary
}

function enterTrade(isLong, i, margin) {
  ASSETS.trade = {}
  ASSETS.trade.barOpen = ASSETS.trade.barClose = i
  ASSETS.trade.isLong = isLong
  ASSETS.trade.strikePrice = priceData.series[i]
  ASSETS.trade.margin = margin
  ASSETS.trade.current = margin
  ASSETS.funds = ASSETS.funds - margin
  ASSETS.trades.push(ASSETS.trade)
}

function exitTrade() {
  ASSETS.funds = ASSETS.funds + ASSETS.trade.current
  ASSETS.trade = null
}

function updateTrade(i) {
  if (!ASSETS.trade) {
    return
  }
  ASSETS.trade.barClose = i
  const longValue = ASSETS.trade.margin / ASSETS.trade.strikePrice * priceData.series[i+1]
  if (ASSETS.trade.isLong) {
    ASSETS.trade.current = longValue
  } else {
    // ASSETS.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // ASSETS.margin / ASSETS.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti ASSETS.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    ASSETS.trade.current = 2 * ASSETS.trade.margin - longValue
  }
}

function parsePriceData(data) {
  const fromIndex = Math.floor(Math.random() * (data.values.length - GAME_LENGTH_TICKS - 2))
  const series = data.values.slice(fromIndex, fromIndex + GAME_LENGTH_TICKS + 2)
  const min = Math.min(...series)
  const max = Math.max(...series)
  return {
    series: series,
    min: min,
    max: max,
    runningMin: series[0],
    runningMax: series[0],
    scale: H / 2 / (max - min),
  }
}

function addInputListeners() {
  window.addEventListener('keydown', event => {
    if (!gameStarted) {
      gameStarted = true
      ENTITIES.messages.summary.text = ''
      return
    }
    if (event.key === 's') {
      INPUT.short = true
    } else if (event.key === 'l') {
      INPUT.long = true
    } else if (gameOver) {
      gameOver = false
      gameStarted = false
      setup()
    }
  }, false)
  window.addEventListener('keyup', event => {
    if (event.key === 's') {
      INPUT.short = false
    }
    if (event.key === 'l') {
      INPUT.long = false
    }
  }, false)
}

function setupBaseLines() {
  let baselines = new PIXI.Container()
  let baselineStart = new PIXI.Graphics()
  baselineStart.position.set(0, H/2)
  baselineStart.lineStyle(1, BASELINE_COLOR)
    .moveTo(0, 0)
    .lineTo(W, 0)
  baselines.addChild(baselineStart)

  p0 = priceData.series[0]
  //console.log('p0=' + p0)

  for (i = 1; i <= 10; i++) {
    ppi = p0 * Math.pow(1.1, i)
    //console.log('pp_' + i + '=' + ppi)
    let baselinePlus = new PIXI.Graphics()
    baselinePlus.position.set(0, H/2 - priceData.scale * (ppi - p0))
    baselinePlus.lineStyle(1, BASELINE_COLOR)
      .moveTo(0, 0)
      .lineTo(W, 0)
    baselines.addChild(baselinePlus)

    pmi = p0 * Math.pow(0.9, i)
    //console.log('pm_' + i + '=' + pmi)
    let baselineMinus = new PIXI.Graphics()
    baselineMinus.position.set(0, H/2 - priceData.scale * (pmi - p0))
    baselineMinus.lineStyle(1, BASELINE_COLOR)
      .moveTo(0, 0)
      .lineTo(W, 0)
    baselines.addChild(baselineMinus)
  }
  ENTITIES.baselines = baselines
  app.stage.addChild(baselines)
}
    </script>
  </body>
</html>
