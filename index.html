<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Crypt surfer</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
    <style>* {padding: 0; margin: 0}</style>
  </head>
  <body>
    <script>

const CONF = {
  width: 1024,
  height: 768,
  antialias: true,
  transparent: false,
  resolution: 1
};

const app = new PIXI.Application(CONF);
const W = window.innerWidth
const H = window.innerHeight
// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.autoResize = true;
app.renderer.resize(W, H);

document.body.appendChild(app.view);

const BITCOIN_PRICE = 'https://api.coindesk.com/v1/bpi/historical/close.json?start=2011-01-01&end=2018-12-01&currency=USD'

PIXI.loader
  .add('bg', 'bg_tile.jpg')
  .add('prices', BITCOIN_PRICE)
  .load(setup);

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: 'Arial',
  fontSize: 18,
  fill: 0xcccccc,
});


function defaultEntities() {
  return {
    bgSprites: [],
    player: null,
    messages: {
      iteration: null,
      funds: null,
      position: null,
    },
    lines: [],
  }
}

var ENTITIES = defaultEntities()

const INIT_FUNDS = 10000
const RESERVE = 0.9
const GAME_LENGTH_TICKS = 10

var ASSETS = {
  funds: INIT_FUNDS,
  volume: null,
  short: null,
  long: null,
}

var priceData

function setup() {
  addInputListeners()
  priceData = parsePriceData(PIXI.loader.resources.prices.data)
  const bgTexture = PIXI.loader.resources.bg.texture
  const w = bgTexture.width
  const h = bgTexture.height
  for (let i = -w; i < W; i += w) {
    for (let j = -h; j < H; j += h) {
      let bgSprite = new PIXI.Sprite(bgTexture)
      bgSprite.position.set(i, j)
      app.stage.addChild(bgSprite);
      ENTITIES.bgSprites.push(bgSprite)
    }
  }

  ENTITIES.player = new PIXI.Graphics()
  ENTITIES.player.lineStyle(2, 0xFF00FF)
  ENTITIES.player.drawCircle(W/2, H/2, 4)
  ENTITIES.player.endFill()
  app.stage.addChild(ENTITIES.player)

  var x = 4
  var y = 4
  const ROW_HEIGHT = 20
  ENTITIES.messages.iteration = new PIXI.Text('tick: ', TEXT_STYLE)
  ENTITIES.messages.iteration.position.set(x, y)
  app.stage.addChild(ENTITIES.messages.iteration);
  y += ROW_HEIGHT

  ENTITIES.messages.funds = new PIXI.Text('funds: $' + ASSETS.funds, TEXT_STYLE)
  ENTITIES.messages.funds.position.set(x, y)
  app.stage.addChild(ENTITIES.messages.funds);

  ENTITIES.messages.position = new PIXI.Text('', TEXT_STYLE)
  ENTITIES.messages.position.position.set(W/2 + 32, H/2 - 12)
  app.stage.addChild(ENTITIES.messages.position);

  ENTITIES.messages.summary = new PIXI.Text('', TEXT_STYLE)
  ENTITIES.messages.summary.position.set(W/2 + 32, H/2 - 12)
  app.stage.addChild(ENTITIES.messages.summary);

  app.ticker.add(update);
}

var time = 0
const LINE_WIDTH = 10

var diff
var gameOver = false

const INPUT = {
  short: false,
  long: false,
}

function positionToColor() {
  return INPUT.short ? 0xff0000 :
      INPUT.long ? 0x00ff55 :
      0xeeeeee
}
function positionToThickness() {
  return INPUT.short || INPUT.long ? 2 : 1
}

function update(dt) {

  time += dt / 60
  var i = Math.min(Math.floor(time), GAME_LENGTH_TICKS)
  if (i >= GAME_LENGTH_TICKS) {
    gameOver = true
    if (ASSETS.long) {
      closeLong()
    }
    if (ASSETS.short) {
      closeShort()
    }
    ENTITIES.messages.iteration.text = 'tick: ' + i + ' / ' + GAME_LENGTH_TICKS
    ENTITIES.messages.funds.text = 'funds: $' + Math.round(ASSETS.funds)
    ENTITIES.messages.position.text = ''

    const result = ASSETS.funds - INIT_FUNDS
    const resultPercent = (result / INIT_FUNDS * 100).toFixed(1)
    var summary = result > 0 ?
        ('YAY! You made a nice return: ' + resultPercent + '%') :
        ('ONOES! You lost ' + resultPercent + '% of your investment')
    summary += '\nPeriod: ' + priceData.from + ' - ' + priceData.to
    summary += '\nPrice range: $' + priceData.min + ' - $' + priceData.max
    summary += '\n\nPress any key to start again'
    ENTITIES.messages.summary.text = summary
    return
  }
  if (ENTITIES.lines.length === i) {

    if (INPUT.long && !ASSETS.long) {
      openLong(i)
    }
    if (INPUT.short && !ASSETS.short) {
      openShort(i)
    }
    if (!INPUT.long && ASSETS.long) {
      closeLong()
    }
    if (!INPUT.short && ASSETS.short) {
      closeShort()
    }

    console.log(priceData.series[i], priceData.series[i+1])

    let line = new PIXI.Graphics();
    line.position.set(W/2, H/2);

    diff = priceData.series[i + 1] - priceData.series[i]
    line.lineStyle(positionToThickness(), positionToColor())
        .moveTo(0, 0)
        .lineTo(LINE_WIDTH, -priceData.scale * diff)

    ENTITIES.lines.push(line)
    app.stage.addChild(line)

    if (ASSETS.long) {
      ASSETS.long = ASSETS.volume / ASSETS.strikePrice * priceData.series[i+1]
      ENTITIES.messages.position.text = 'long: $' + Math.round(ASSETS.long) + ' (' + Math.round(ASSETS.long - ASSETS.volume) + ')'
    } else if (ASSETS.short) {
      // ASSETS.volume dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
      // ennyi bitcoint adtam el eredetileg:
      // ASSETS.volume / ASSETS.strikePrice
      // === ennyit kell visszaadjak ma
      // nekem meg megvan az eredeti ASSETS.volume dolcsim
      // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
      // bwahahaha
      const longValue = ASSETS.volume / ASSETS.strikePrice * priceData.series[i+1]
      ASSETS.short = 2*ASSETS.volume - longValue

      ENTITIES.messages.position.text = 'short: $' + Math.round(ASSETS.short) + ' (' + Math.round(ASSETS.short - ASSETS.volume) + ')'
    } else {
      ENTITIES.messages.position.text = ''
    }

    ENTITIES.messages.iteration.text = 'tick: ' + i + ' / ' + GAME_LENGTH_TICKS
    ENTITIES.messages.funds.text = 'funds: $' + Math.round(ASSETS.funds)

  }
  ENTITIES.lines.forEach(line => {
    line.x -= LINE_WIDTH / 60 * dt
    line.y += priceData.scale * diff / 60 * dt
  })
}

function openLong(i) {
  ASSETS.strikePrice = priceData.series[i]
  ASSETS.volume = ASSETS.funds * (1-RESERVE)
  ASSETS.funds = ASSETS.funds - ASSETS.volume
  ASSETS.long = ASSETS.volume
}

function closeLong() {
  ASSETS.funds = ASSETS.funds + ASSETS.long
  ASSETS.long = null
  ASSETS.volume = null
}

function openShort(i) {
  ASSETS.strikePrice = priceData.series[i]
  ASSETS.volume = ASSETS.funds * (1-RESERVE)
  ASSETS.funds = ASSETS.funds - ASSETS.volume
  ASSETS.short = ASSETS.volume
}

function closeShort() {
  ASSETS.funds = ASSETS.funds + ASSETS.short
  ASSETS.short = null
  ASSETS.volume = null
}

function parsePriceData(data) {
  const days = Object.keys(data.bpi)
  days.sort()
  const fromIndex = Math.floor(Math.random() * (days.length - GAME_LENGTH_TICKS -2))
  const series = days.slice(fromIndex, fromIndex + GAME_LENGTH_TICKS + 2).map(day => data.bpi[day])
  const min = Math.min(...series)
  const max = Math.max(...series)
  return {
    series: series,
    min: min,
    max: max,
    scale: H / 2 / (max - min),
    from: days[fromIndex],
    to: days[fromIndex+GAME_LENGTH_TICKS],
  }
}

function addInputListeners() {
  window.addEventListener('keydown', event => {
    if (event.key === 's') {
      INPUT.short = true
      INPUT.long = false
    } else if (event.key === 'l') {
      INPUT.long = true
      INPUT.short = false
    } else if (gameOver) {
      gameOver = false
      time = 0
      ENTITIES = defaultEntities()
      ASSETS.funds = INIT_FUNDS
      app.ticker.remove(update);
      setup()
    }
  }, false)
  window.addEventListener('keyup', event => {
    if (event.key === 's') {
      INPUT.short = false
    }
    if (event.key === 'l') {
      INPUT.long = false
    }
  }, false)
}

    </script>
  </body>
</html>
