<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Crypto Climber</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
    <script src="pixi-multistyle-text/0.6.0/pixi-multistyle-text.umd.js"></script>
    <style>* {padding: 0; margin: 0}</style>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  </head>
  <body>
    <script>

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = parseInt(getQueryParam('days'), 10) || 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY
const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const OFFSET_X = 0.33

const SHOW_PRICE = false
const SHOW_DEBUG = false

const MIN_SPEED = 12 // smaller is faster
const MAX_SPEED = 6 // smaller is faster
const WARP_SPEED_DELTA = (MIN_SPEED - MAX_SPEED) / 30
var SPEED = MIN_SPEED

const MIN_ZOOM = 1
const MAX_ZOOM = 1.5
const WARP_ZOOM_DELTA = (MAX_ZOOM - MIN_ZOOM) / 30
var ZOOM = MAX_ZOOM

const INTRO =
  '<title>Crypto Climber</title>\n\n' +
  'How good are you at trading' +
  '\na ' + GAME_LENGTH_DAYS + ' day sample of' +
  '\nhistorical Bitcoin prices?' +
  '<strong>' +
  '\n\nHold [L] to go LONG' +
  '\nHold [S] to sell SHORT' +
  '</strong>' +
  '\n\nHold [SHIFT] for warp speed' +
  '\n\n<strong>Press [SPACE] to start!</strong>'

const HODL_NAME = 'Buy and hold'

const CONF = {
  width: 1024,
  height: 768,
  antialias: true,
  transparent: false,
  resolution: 1
};

const app = new PIXI.Application(CONF);
const SCREEN_WIDTH = window.innerWidth
const SCREEN_HEIGHT = window.innerHeight
const SHEET_URL = 'https://script.google.com/macros/s/AKfycbyDTk5pYHGjgHartXZZX876CZbKYa_kKljZDEOJ1dylwVSn1Mk/exec'

// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.autoResize = true;
app.renderer.resize(SCREEN_WIDTH, SCREEN_HEIGHT);


document.body.appendChild(app.view);

PIXI.loader
.add('bg', 'bg_tile.jpg')
.add('prices', 'btc1h.json')
.load(() => {
  // TODO: load font concurrently with resources
  WebFont.load({
    google: {
      families: ['B612 Mono']
    },
    active: setup
  })
});


const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 28,
  fill: 0xffffff,
  align: 'center',
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_MULTI_STYLE = {
  'default': {
    fontFamily: '"B612 Mono", monospace',
    fontSize: 20,
    fill: 0xcccccc,
    align: 'center',
    dropShadow: true,
    dropShadowAlpha: 0.6,
    dropShadowBlur: 10,
    dropShadowDistance: 3,
  },
  'strong': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'title': {
    fontSize: 28,
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'self': {
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'hodl': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'profit': {
    fontWeight: 'bold',
    fill: 0x00ff00,
  },
  'loss': {
    fontWeight: 'bold',
    fill: 0xff0000,
  },
  'tr': {
    fill: 0x666666,
  },
};

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});


function defaultEntities() {
  return {
    gamespace: null,
    messages: {
      iteration: null,
      funds: null,
      summary: null,
      price: null,
      debug: null,
    },
    baselines: null,
    lines: [],
    player: null,
  }
}
var ENTITIES = defaultEntities()

var ASSETS = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
  scores: [],
}

function getQueryParam(param) {
    var query = window.location.search.substring(1);
    var vars = query.split('&');
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == param) {
            return decodeURIComponent(pair[1]);
        }
    }
    return null;
}

var priceData
var player = getQueryParam('player')

function callback(p) {
  var data = JSON.parse(p)
  if (gameOver && data.result == 'success') {
    data.top.forEach(entry => {
      addScore(entry[0], entry[1], entry[3])
    })
    showScores()
  }
}

function addScore(player, result, trades) {
  ASSETS.scores.push({
    player: player,
    result: Math.round(result * 1000) / 1000,
    trades: trades
  })
}

function uniqueSorted(arr, cmp) {
  return arr.sort(cmp).filter((e, i, arr) => !i || cmp.apply(null, [e, arr[i - 1]]) != 0)
}

function tag(tag, string) {
  return (tag ? '<' + tag + '>' : '')
    + string
    + (tag ? '</' + tag + '>' : '')
}

function showScores() {
  let text = '<strong>RESULTS</strong>\nfor the same time period\n'
  ASSETS.scores = uniqueSorted(ASSETS.scores, (a, b) => b.result - a.result || a.player.localeCompare(b.player))
  ASSETS.scores.forEach(e => {
    text += '\n'
      + tag(e.player == player ? 'self' : (e.player == HODL_NAME ? 'hodl' : null),
        e.player.slice(0, 14).padEnd(14, ' ')
        + tag(e.result >= 0 ? 'profit' : 'loss', toPercent(e.result).padStart(8, ' '))
        + tag('tr', (' (' + toTrades(e.trades) + ')').padEnd(14, ' '))
      )
  })
  text += '\n\nPress [SPACE] to restart'
  ENTITIES.messages.summary.text = text
}

function saveResult(returns, hodl, trades) {
  var q = '?player=' + encodeURIComponent(player)
  q += '&return=' + encodeURIComponent(returns.toFixed(3))
  q += '&hodl=' + encodeURIComponent(hodl.toFixed(3))
  q += '&trades=' + encodeURIComponent(trades)
  var t = new Date().toISOString().substr(0, 19).replace('T', ' ')
  q += '&time=' + encodeURIComponent(t)
  q += '&start=' + encodeURIComponent(priceData.startTick)
  q += '&stop=' + encodeURIComponent(priceData.stopTick)
  var scr = document.createElement('script')
  scr.src = SHEET_URL + q
  document.body.appendChild(scr)
}

function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  time = 0
  tick = -1
  SPEED = MIN_SPEED
  ZOOM = MAX_ZOOM

  ENTITIES = defaultEntities()
  ASSETS.funds = INIT_FUNDS
  ASSETS.trades = []
  ASSETS.scores = []
  ASSETS.trade = null
  priceData = parsePriceData(PIXI.loader.resources.prices.data)
  GAME_WIDTH = (priceData.series.length - 1) * GRAPH_X_GRANULARITY_PX
  GAME_HEIGHT = (priceData.max - priceData.min) * priceData.scale

  // app.stage.addChild(createBackground())

  ENTITIES.gamespace = new PIXI.Container()
  ENTITIES.gamespace.addChild(createGrid())
  ENTITIES.gamespace.addChild(createGraph())
  ENTITIES.gamespace.addChild(createPlayer())
  app.stage.addChild(ENTITIES.gamespace)

  app.stage.addChild(createMessages())

  setViewPort(0, 0, OFFSET_X)
  addInputListeners()
  app.ticker.add(update)
}

function createBackground() {
  background = new PIXI.Container()
  const bgTexture = PIXI.loader.resources.bg.texture
  const w = bgTexture.width
  const h = bgTexture.height
  for (let i = -w; i < SCREEN_WIDTH; i += w) {
    for (let j = -h; j < SCREEN_HEIGHT; j += h) {
      let bgSprite = new PIXI.Sprite(bgTexture)
      bgSprite.position.set(i, j)
      bgSprite.alpha = 0.5
      background.addChild(bgSprite)
    }
  }
  return background
}

function createMessages() {
  messagesContainer = new PIXI.Container()

  var x = 4
  var y = 4
  const ROW_HEIGHT = 30
  ENTITIES.messages.iteration = new PIXI.Text('Day 1 of ' + GAME_LENGTH_DAYS, TEXT_STYLE)
  ENTITIES.messages.iteration.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.iteration)
  y += ROW_HEIGHT

  ENTITIES.messages.funds = new PIXI.Text('Equity $' + ASSETS.funds, TEXT_STYLE)
  ENTITIES.messages.funds.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    ENTITIES.messages.price = new PIXI.Text('price: $', TEXT_STYLE)
    ENTITIES.messages.price.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    ENTITIES.messages.debug = new PIXI.Text('', TEXT_STYLE)
    ENTITIES.messages.debug.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.debug)
    y += ROW_HEIGHT
  }

  ENTITIES.messages.summary = new MultiStyleText(INTRO, TEXT_MULTI_STYLE)
  ENTITIES.messages.summary.position.set(SCREEN_WIDTH/2, SCREEN_HEIGHT/2)
  ENTITIES.messages.summary.anchor.set(0.5, 0.5)
  messagesContainer.addChild(ENTITIES.messages.summary)

  return messagesContainer
}

function gradientTexture(w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w
  canvas.height = h
  var ctx = canvas.getContext('2d')
  var gradient = ctx.createLinearGradient(0, 0, 0, h)
  gradient.addColorStop(0, '#000000')
  gradient.addColorStop(1, '#ffffff')
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, w, h)
  return PIXI.Texture.fromCanvas(canvas)
}

function createGrid() {
  const p0 = priceData.series[0]

  const margin = SCREEN_WIDTH * ZOOM
  let grid = new PIXI.Container()

  const gradHeight = 256
  const grad = gradientTexture(1, gradHeight)

  let ppi = p0
  //for (i = 1; ppi < priceData.max; i++) {
  for (let i = 1; i <= 20; i++) {
    let prevY = priceData.scale * (ppi - p0)
    ppi *= 1.1
    let y = priceData.scale * (ppi - p0)
  
    var sprite = new PIXI.Sprite(grad)
    sprite.x = -margin
    sprite.y = prevY
    sprite.alpha = 0.12
    sprite.scale.set(GAME_WIDTH + (2 * margin), (y - prevY) / gradHeight)
    grid.addChild(sprite)
  }

  let pmi = p0
  //for (i = 1; pmi > priceData.min; i++) {
  for (let i = 1; i <= 20; i++) {
    let prevY = priceData.scale * (pmi - p0)
    pmi *= 0.9
    let y = priceData.scale * (pmi - p0)

    var sprite = new PIXI.Sprite(grad)
    sprite.x = -margin
    sprite.y = y
    sprite.alpha = 0.12
    sprite.scale.set(GAME_WIDTH + (2 * margin), (prevY - y) / gradHeight)
    grid.addChild(sprite)
  }

  let days = new PIXI.Graphics()
  days.lineStyle(2, 0x222222)
  const mul = 24 * GRAPH_X_GRANULARITY_PX
  for (let i = 0; i <= GAME_LENGTH_DAYS; i++) {
    days.moveTo(i * mul, -2 * SCREEN_HEIGHT)
        .lineTo(i * mul, 2 * SCREEN_HEIGHT)
  }
  grid.addChild(days)

  ENTITIES.grid = grid
  return grid
}

function createPlayer() {
  ENTITIES.player = new PIXI.Graphics()
  ENTITIES.player.alpha = 0.2
  ENTITIES.player.lineStyle(4, 0xffffff)
  ENTITIES.player.drawCircle(0, 0, 8)
  ENTITIES.player.endFill()
  return ENTITIES.player
}

function createGraph() {
  let p0 = priceData.series[0]
  let graph = new PIXI.Container()
  for (let i = 0; i < priceData.series.length - 1; i++) {
    let line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(2, 0xffffff)
        .moveTo(GRAPH_X_GRANULARITY_PX * i, priceData.scale * (priceData.series[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 1), priceData.scale * (priceData.series[i + 1] - p0))
    line.visible = false
    ENTITIES.lines.push(line)
    graph.addChild(line)
  }
  return graph
}

function setViewPort(x, y, xOffset) {
  ENTITIES.gamespace.scale.x = ZOOM
  ENTITIES.gamespace.scale.y = -ZOOM
  ENTITIES.gamespace.position.x = -(x * ZOOM - SCREEN_WIDTH / 2 - (SCREEN_WIDTH * xOffset))
  ENTITIES.gamespace.position.y = -(-y * ZOOM - SCREEN_HEIGHT / 2)
}

function movePlayer(x, y) {
  ENTITIES.player.x = x
  ENTITIES.player.y = y
}

var time = 0
var tick = -1

var gameOver = false
var gameStarted = false

const INPUT = {
  short: false,
  long: false,
  warp: false,
}

function update(dt) {
  if (!gameStarted) {
    return
  }

  if (INPUT.warp) {
    SPEED = Math.max(MAX_SPEED, SPEED - WARP_SPEED_DELTA)
    ZOOM = Math.max(MIN_ZOOM, ZOOM - WARP_ZOOM_DELTA)
  } else {
    SPEED = Math.min(MIN_SPEED, SPEED + WARP_SPEED_DELTA)
    ZOOM = Math.min(MAX_ZOOM, ZOOM + WARP_ZOOM_DELTA)
  }

  time += dt / SPEED
  var i = Math.floor(time)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      showGameOver()
    }
    return
  }

  x = time * GRAPH_X_GRANULARITY_PX
  y = priceData.scale * ((priceData.series[tick] - priceData.series[0])
    + (time - tick) * (priceData.series[tick + 1] - priceData.series[tick]))
  setViewPort(x, y, OFFSET_X)
  movePlayer(x, y)
  updateTrade(i)

  if (i > tick) {
    tick = i

    const currentPrice = priceData.series[i]
    priceData.runningMin = Math.min(priceData.runningMin, currentPrice)
    priceData.runningMax = Math.max(priceData.runningMax, currentPrice)

    handleInput(i)

    ENTITIES.lines[i].visible = true

    updatePlayer()
    updateMessages(i)
  }


}

function handleInput(i) {
  if (INPUT.long && !INPUT.short) {
    // LONG
    if (ASSETS.trade) {
      if (ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(true, i, ASSETS.funds)
  } else if (!INPUT.long && INPUT.short) {
    // SHORT
    if (ASSETS.trade) {
      if (!ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(false, i, ASSETS.funds)
  } else {
    // NEUTRAL
    if (ASSETS.trade) {
      exitTrade()
    }
  }
}

function updatePlayer() {
  ENTITIES.player.alpha = ASSETS.trade ? 0.5 : 0.2
}

function updateMessages(i) {
  ENTITIES.messages.summary.text = ''

  ENTITIES.messages.iteration.text = 'Day ' + (Math.floor(i / TICKS_PER_DAY) + 1) + ' of ' + GAME_LENGTH_DAYS
  var equity = ASSETS.funds + (ASSETS.trade ? ASSETS.trade.current : 0)

  ENTITIES.messages.funds.text = 'Equity $' + Math.round(equity)
  if (SHOW_PRICE) {
    ENTITIES.messages.price.text = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    ENTITIES.messages.debug.text =
      'inputs: ' + (INPUT.short?'S':' ') + (INPUT.long?'L':' ') + (INPUT.warp?'W':' ')
      + ' trade: ' + (ASSETS.trade ? (ASSETS.trade.isLong ? 'L' : 'S') : '-')
      + ' speed: ' + (SPEED.toFixed(2)) + ' zoom: ' + (ZOOM.toFixed(2))
  }
}

function toTrades(num) {
  return num === 0 ? 'no trades' :
    num === 1 ? '1 trade' :
    num + ' trades'
}

function toPercent(num) {
  return (num * 100).toFixed(1) + '%'
}

function toAbsPercent(num) {
  return toPercent(Math.abs(num))
}

function showGameOver() {
  if (ASSETS.trade) {
    exitTrade()
  }
  updateMessages(GAME_LENGTH_TICKS - 1)

  const profit = ASSETS.funds - INIT_FUNDS
  const returns = profit / INIT_FUNDS
  const hodlReturns = priceData.series[GAME_LENGTH_TICKS] / priceData.series[0] - 1
  const beatsHodl = returns > hodlReturns

  ZOOM = SCREEN_WIDTH / GAME_WIDTH
  setViewPort(GAME_WIDTH / 2, 0, 0)

  setTimeout(() => {
    if (!player) {
      player = window.prompt('Nick name?') || 'anonymous';
    }
    addScore(player, returns, ASSETS.trades.length)
    addScore(HODL_NAME, hodlReturns, 1)
    showScores()
    saveResult(returns, hodlReturns, ASSETS.trades.length)
  })
}

function enterTrade(isLong, i, margin) {
  ASSETS.trade = {}
  ASSETS.trade.barOpen = ASSETS.trade.barClose = i
  ASSETS.trade.isLong = isLong
  ASSETS.trade.strikePrice = priceData.series[i]
  ASSETS.trade.margin = margin
  ASSETS.trade.current = margin
  ASSETS.funds = ASSETS.funds - margin
  ASSETS.trades.push(ASSETS.trade)
}

function exitTrade() {
  ASSETS.funds = ASSETS.funds + ASSETS.trade.current
  ASSETS.trade = null
}

function updateTrade(i) {
  if (!ASSETS.trade) {
    return
  }
  ASSETS.trade.barClose = i

  // TODO: interpolate estimated price between ticks
  const longValue = ASSETS.trade.margin / ASSETS.trade.strikePrice * priceData.series[i]
  if (ASSETS.trade.isLong) {
    ASSETS.trade.current = longValue
  } else {
    // ASSETS.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // ASSETS.margin / ASSETS.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti ASSETS.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    ASSETS.trade.current = 2 * ASSETS.trade.margin - longValue
  }

  const profit = Math.round(ASSETS.trade.current - ASSETS.trade.margin)

  // update label
  if (!ASSETS.trade.label) {
    ASSETS.trade.label = new PIXI.Text('', TEXT_STYLE)
    ASSETS.trade.label.scale.set(1 / ZOOM, -1 / ZOOM)
    ASSETS.trade.label.zOrder = -ASSETS.trades.length
    ENTITIES.gamespace.addChild(ASSETS.trade.label)
  }
  ASSETS.trade.label.position.set(x - 15, y + (ASSETS.trade.isLong ? -10 : 20))

  ASSETS.trade.label.text = (profit < 0 ? ' -$' : ' +$') + Math.abs(profit)
  ASSETS.trade.label.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE

  // update trade line
  if (ASSETS.trade.line) {
    ENTITIES.gamespace.removeChild(ASSETS.trade.line)
  }

  const color = profit < 0 ? 0xff0000 : 0x00ff00
  ASSETS.trade.line = new PIXI.Graphics()
  const a = ASSETS.trade.barOpen
  ASSETS.trade.line.lineStyle(5, color, 0.66)
    .moveTo(a * GRAPH_X_GRANULARITY_PX, priceData.scale * (priceData.series[a] - priceData.series[0]))
    .lineTo(x, y)
  ENTITIES.gamespace.addChild(ASSETS.trade.line)

}

function parsePriceData(data) {
  const chunks = Math.floor(data.values.length / GAME_LENGTH_TICKS)
  const fromIndex = GAME_LENGTH_TICKS * Math.floor(Math.random() * chunks)
  const series = data.values.slice(fromIndex, fromIndex + GAME_LENGTH_TICKS + 1)
  const first = series[0]
  return {
    series: series,
    pastSeries: pastSeries,
    min: Math.min(...series),
    max: Math.max(...series),
    runningMin: first,
    runningMax: first,
    scale: SCREEN_HEIGHT / 2 / (first * 1.1 * 1.1 - first * 0.9 * 0.9),
    startTick: fromIndex,
    stopTick: fromIndex + GAME_LENGTH_TICKS,
  }
}

function addInputListeners() {
  window.addEventListener('blur', event => {
    INPUT.short = INPUT.long = INPUT.warp = false
  }, false)
  window.addEventListener('keydown', event => {
    if (!gameStarted && event.code === 'Space') {
      gameStarted = true
      ENTITIES.messages.summary.text = ''
      return
    }
    if (event.code === 'KeyS' || event.code === 'ArrowDown') {
      INPUT.short = true
    } else if (event.code === 'KeyL' || event.code === 'ArrowUp') {
      INPUT.long = true
    } else if (gameOver && event.code === 'Space') {
      gameOver = false
      gameStarted = false
      setup()
    }
    if (event.key === 'Shift') {
      INPUT.warp = true
    }
  }, false)
  window.addEventListener('keyup', event => {
    if (event.code === 'KeyS' || event.code === 'ArrowDown') {
      INPUT.short = false
    }
    if (event.code === 'KeyL' || event.code === 'ArrowUp') {
      INPUT.long = false
    }
    if (event.key === 'Shift') {
      INPUT.warp = false
    }
  }, false)
}

    </script>
  </body>
</html>
