<!doctype html>
<html prefix="og: http://ogp.me/ns#">
  <head>
    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-130030503-3"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'UA-130030503-3');
    </script>

    <meta charset="utf-8">
    <meta id="viewport" name="viewport" content="">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <style>* {padding: 0; margin: 0; overflow: hidden;}</style>

    <title>Crypto Climber</title>
    <meta property="og:title" content="Crypto Climber" />
    <meta property="og:type" content="website" />
    <meta property="og:url" content="https://cryptoclimber.decent.org/" />
    <meta property="og:image" content="https://cryptoclimber.decent.org/og.png" />
    <meta property="og:description" content="Fun little game about bitcoin trading" />

    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.5/pixi.min.js"></script>
    <script src="pixi-multistyle-text/0.6.0/pixi-multistyle-text.umd.js"></script>
    <script src="https://ajax.googleapis.com/ajax/libs/webfont/1.6.26/webfont.js"></script>
  </head>
  <body>
    <script>


// ===== constants =====

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = parseInt(getQueryParam('days'), 10) || 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY

const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const Y_SCALE_FACTOR = 1000

const OFFSET_X = 0.25
const SMOOTH_FACTOR_Y = 50

const MARGIN = 15
const BUTTON_WIDTH = 160
const BUTTON_HEIGHT = 80

const SHOW_PRICE = false
const SHOW_DEBUG = false

const MIN_SPEED = 12 // smaller is faster
const MAX_SPEED = 4 // smaller is faster
const WARP_SPEED_DELTA = (MIN_SPEED - MAX_SPEED) / 30

const MIN_ZOOM = 0.75
const MAX_ZOOM = 1.25
const WARP_ZOOM_DELTA = (MAX_ZOOM - MIN_ZOOM) / 30

const INTRO =
  'How good are you at trading' +
  '\na ' + GAME_LENGTH_DAYS + ' day sample of' +
  '\nhistorical Bitcoin prices?' +
  '<strong>' +
  '\n\nPress [UP] to go LONG' +
  '\nPress [DOWN] to sell SHORT' +
  '\nPress [SPACE] to close position ' +
  '</strong>' +
  '\n\nHold [SHIFT] for warp speed' +
  '\n\n<strong>Press [SPACE] to start!</strong>'

const HODL_NAME = 'Buy and hold'

const SHEET_URL = 'https://script.google.com/macros/s/AKfycbyDTk5pYHGjgHartXZZX876CZbKYa_kKljZDEOJ1dylwVSn1Mk/exec'

const DEFAULT_TEXTS = Object.freeze({
  summary: INTRO,
  highscores: '',
  iteration: '',
  funds: '',
  price: '',
  debug: '',
})

const COLOR_BUTTON_INACTIVE = 0xffffff
const COLOR_BUTTON_ACTIVE = 0xff00ff
const COLOR_BUTTON_WARP_ACTIVE = 0xffff00


// ===== global variables =====

let screenWidth = window.innerWidth
let screenHeight = window.innerHeight

let speed = MIN_SPEED
let zoom = MAX_ZOOM

let texts = Object.assign({}, DEFAULT_TEXTS)

let entities = {
  gamespace: null,
  tradelines: null,
  tradelabels: null,
  ui: null,
  messages: {
    iteration: null,
    funds: null,
    summary: null,
    highscores: null,
    price: null,
    debug: null,
  },
  logos: null,
  lines: [],
  player: null,
}

let assets = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
  scores: [],
}

let priceData = {}
let player = getQueryParam('player')

let viewPortX = 0
let viewPortY = 0

let time = 0
let tick = -1

let gameOver = false
let gameStarted = false

let input = {
  short: false,
  long: false,
  warp: false,
}

let fps = 60

// ===== startup code =====

if (window.navigator.userAgent.includes('iPhone')) {
  document.getElementById("viewport").setAttribute("content",
      "minimal-ui, width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5, user-scalable=no")
}

const app = new PIXI.Application({
  width: window.innerWidth,
  height: window.innerHeight,
  antialias: false,
  transparent: false,
  resolution: window.devicePixelRatio,
  preserveDrawingBuffer: true,
});

// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.view.style.overflow = 'hidden';
app.renderer.autoResize = true;

screenWidth = window.innerWidth
screenHeight = window.innerHeight
app.renderer.resize(screenWidth, screenHeight);

document.body.appendChild(app.view);

PIXI.loader
  .add('prices', 'btc1h.json')
  .load(() => {
    // TODO: load font concurrently with resources
    WebFont.load({
      google: {
        families: ['B612 Mono']
      },
      active: setup
    })
  });


// ===== setup and layout =====

function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  gameOver = false
  gameStarted = false

  time = 0
  tick = -1
  speed = MIN_SPEED
  zoom = MAX_ZOOM

  assets.funds = INIT_FUNDS
  assets.trades = []
  assets.scores = []
  assets.trade = null

  priceData = parsePriceData(PIXI.loader.resources.prices.data, GAME_LENGTH_TICKS)

  entities.gamespace = new PIXI.Container()
  entities.gamespace.addChild(createGrid())

  let {graph, lines} = createGraph()
  entities.gamespace.addChild(graph)
  entities.lines = lines

  entities.player = createPlayer()
  entities.gamespace.addChild(entities.player)

  entities.tradelines = new PIXI.Container()
  entities.gamespace.addChild(entities.tradelines)

  entities.tradelabels = new PIXI.Container()
  entities.gamespace.addChild(entities.tradelabels)

  app.stage.addChild(entities.gamespace)

  texts = Object.assign({}, DEFAULT_TEXTS)
  setupUI(screenWidth, screenHeight);

  onNeutral()
  showControls(false)
  setViewPort(0, 0, OFFSET_X)

  addInputListeners()
  app.ticker.add(update)
}

function setupUI(width, height) {
  app.stage.removeChild(entities.ui)

  let uiContainer = new PIXI.Container()
  entities.ui = uiContainer

  let {messagesContainer, messages} = createMessages(width, height, MARGIN)
  uiContainer.addChild(messagesContainer)
  entities.messages = messages

  entities.logos = createLogos(width, height, MARGIN)
  uiContainer.addChild(entities.logos)

  entities.smallLogo = createSmallLogo(width, height, MARGIN)
  uiContainer.addChild(entities.smallLogo)

  entities.longButton = createButton("\u25B3 Long ",
    width - BUTTON_WIDTH - MARGIN, height - 3 * BUTTON_HEIGHT - 5 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, input.long,
    (pressed) => {
      if (pressed) {
        onLong()
      }
    })
  uiContainer.addChild(entities.longButton)

  entities.neutralButton = createButton("Neutral",
    width - BUTTON_WIDTH - MARGIN, height - 2 * BUTTON_HEIGHT - 3 * MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, !input.long && !input.short,
    (pressed) => {
      if (pressed) {
        onNeutral()
      }
    })
  uiContainer.addChild(entities.neutralButton)

  entities.shortButton = createButton("\u25BD Short",
    width - BUTTON_WIDTH - MARGIN, height - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, input.short,
    (pressed) => {
      if (pressed) {
        onShort()
      }
    })
  uiContainer.addChild(entities.shortButton)

  entities.warpButton = createButton("\u232A\u232AWarp",
    MARGIN, height - BUTTON_HEIGHT - MARGIN,
    BUTTON_WIDTH, BUTTON_HEIGHT, input.warp, onWarp)
  uiContainer.addChild(entities.warpButton)

  showControls(isGameRunning())
  uiContainer.interactive = true
  uiContainer.on('tap', listenerGlobalTap)
  uiContainer.hitArea = new PIXI.Rectangle(0, 0, width, height)

  app.stage.addChild(uiContainer)
}

function showControls(show) {
  entities.longButton.visible =
  entities.neutralButton.visible =
  entities.shortButton.visible =
  entities.warpButton.visible =
  show
}

function updateTexts() {
  entities.messages.summary.text = texts.summary
  entities.messages.highscores.text = texts.highscores
  entities.messages.iteration.text = texts.iteration
  entities.messages.funds.text = texts.funds
  if (SHOW_PRICE) {
    entities.messages.price.text = texts.price
  }
  if (SHOW_DEBUG) {
    entities.messages.debug.text = texts.debug
  }
}


// ===== update loop =====

function update(dt) {
  if (!gameStarted) {
    return
  }

  if (input.warp) {
    speed = Math.max(MAX_SPEED, speed - WARP_SPEED_DELTA)
    zoom = Math.max(MIN_ZOOM, zoom - WARP_ZOOM_DELTA)
  } else {
    speed = Math.min(MIN_SPEED, speed + WARP_SPEED_DELTA)
    zoom = Math.min(MAX_ZOOM, zoom + WARP_ZOOM_DELTA)
  }

  time += dt / speed
  var i = Math.floor(time)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      gameStarted = false
      showGameOver()
    }
    return
  }

  if (i > tick) {
    tick = i

    const currentPrice = priceData.series[i]
    priceData.runningMin = Math.min(priceData.runningMin, currentPrice)
    priceData.runningMax = Math.max(priceData.runningMax, currentPrice)

    entities.lines[i].visible = true

    handleInput(i)
  }

  var x = time * GRAPH_X_GRANULARITY_PX
  var y = Y_SCALE_FACTOR * priceData.scale * ((priceData.series[tick] - priceData.series[0])
    + (time - tick) * (priceData.series[tick + 1] - priceData.series[tick]))

  setViewPort(x, (viewPortY + (y - viewPortY) / SMOOTH_FACTOR_Y), OFFSET_X)
  movePlayer(x, y)
  updatePlayer()
  updateTrade(tick, x, y)
  updateMessages(tick)
}

function setViewPort(x, y, xOffset) {
  viewPortX = x
  viewPortY = y
  entities.gamespace.scale.x = zoom
  entities.gamespace.scale.y = -zoom
  entities.gamespace.position.x = -(x * zoom - screenWidth / 2 - (screenWidth * xOffset))
  entities.gamespace.position.y = -(-y * zoom - screenHeight / 2)
}

function movePlayer(x, y) {
  entities.player.x = x
  entities.player.y = y
}

function startGame() {
  texts.summary = ''
  texts.highscores = ''
  updateTexts()
  entities.logos.visible = false
  entities.smallLogo.visible = true
  showControls(true)
  gameStarted = true
}

function onWarp(warpState) {
  input.warp = warpState
  entities.warpButton.tint = warpState ? COLOR_BUTTON_WARP_ACTIVE : COLOR_BUTTON_INACTIVE
}

function onLong() {
  input.short = false
  input.long = true
  entities.longButton.tint = COLOR_BUTTON_ACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_INACTIVE
  entities.shortButton.tint = COLOR_BUTTON_INACTIVE
}

function onShort() {
  input.short = true
  input.long = false
  entities.longButton.tint = COLOR_BUTTON_INACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_INACTIVE
  entities.shortButton.tint = COLOR_BUTTON_ACTIVE
}

function onNeutral() {
  input.long = false
  input.short = false
  entities.longButton.tint = COLOR_BUTTON_INACTIVE
  entities.neutralButton.tint = COLOR_BUTTON_ACTIVE
  entities.shortButton.tint = COLOR_BUTTON_INACTIVE
}

function handleInput(i) {
  if (input.long && !input.short) {
    // LONG
    if (assets.trade) {
      if (assets.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(true, i, assets.funds)
  } else if (!input.long && input.short) {
    // SHORT
    if (assets.trade) {
      if (!assets.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(false, i, assets.funds)
  } else {
    // NEUTRAL
    if (assets.trade) {
      exitTrade()
    }
  }
}

function updatePlayer() {
  entities.player.alpha = assets.trade ? 0.5 : 0.2
}

function updateMessages(i) {
  texts.summary = ''
  texts.iteration = 'Day ' + (Math.floor(i / TICKS_PER_DAY) + 1) + ' of ' + GAME_LENGTH_DAYS

  var equity = assets.funds + (assets.trade ? assets.trade.current : 0)
  texts.funds = 'Equity $' + Math.round(equity)

  if (SHOW_PRICE) {
    texts.price = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    fps = fps * 0.95 + app.ticker.FPS * 0.05
    texts.debug =
      'inputs:' + (input.short?'S':' ') + (input.long?'L':' ') + (input.warp?'W':' ')
      + ' trade:' + (assets.trade ? (assets.trade.isLong ? 'L' : 'S') : 'N')
      + '\nspeed:' + speed.toFixed(2)
      + ' zoom:' + zoom.toFixed(2)
      + '\ntick:' + tick
      + ' x:' + viewPortX.toFixed(2)
      + ' y:' + viewPortY.toFixed(2)
      + '\nFPS:' + fps.toFixed(0) + ' (' + app.ticker.FPS.toFixed(2) + ')'
  }
  updateTexts()
}

function showGameOver() {
  onNeutral()
  onWarp(false)
  showControls(false)
  if (assets.trade) {
    exitTrade()
  }
  updateMessages(GAME_LENGTH_TICKS - 1)
  zoomOutFull()

  const profit = assets.funds - INIT_FUNDS
  const returns = profit / INIT_FUNDS
  const hodlReturns = priceData.series[GAME_LENGTH_TICKS] / priceData.series[0] - 1
  const beatsHodl = returns > hodlReturns

  setTimeout(() => {
    if (!player) {
      player = window.prompt('Nick name?') || 'anonymous';
    }
    addScore(true, player, returns, assets.trades.length)
    addScore(false, HODL_NAME, hodlReturns, 1)
    showScores()
    saveResult(returns, hodlReturns, assets.trades.length)
  })
}

function zoomOutFull() {
  zoom = screenWidth / (GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX)
  setViewPort(GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX / 2, 0, 0)
}


// ===== 'create' methods =====

function createGraph() {
  const p0 = priceData.series[0]
  let graph = new PIXI.Container()
  let lines = []

  for (let i = 0; i < priceData.series.length - 1; i++) {
    let line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(2, 0xffffff)
        .moveTo(GRAPH_X_GRANULARITY_PX * i,
          Y_SCALE_FACTOR * priceData.scale * (priceData.series[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 1),
          Y_SCALE_FACTOR * priceData.scale * (priceData.series[i + 1] - p0))
    line.visible = false
    lines.push(line)
    graph.addChild(line)
  }

  const past = priceData.pastSeries.length
  for (let i = 0; i < past; i++) {
    let line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(2, 0x666666)
        .moveTo(GRAPH_X_GRANULARITY_PX * (i + 1 - past),
          Y_SCALE_FACTOR * priceData.scale * (priceData.pastSeries[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 2 - past),
          Y_SCALE_FACTOR * priceData.scale * (priceData.pastSeries[i + 1] - p0))
    graph.addChild(line)
  }

  return {graph, lines}
}

function createButton(text, x, y, w, h, initialState, callback) {
  const g = new PIXI.Graphics()

  const txt = new PIXI.Text(text, TEXT_STYLE)
  txt.x = (w - txt.width) / 2
  txt.y = (h - txt.height) / 2
  g.addChild(txt)

  g.lineStyle(2, COLOR_BUTTON_INACTIVE, 1);
  g.beginFill(COLOR_BUTTON_INACTIVE, 0.25);
  g.drawRoundedRect(0, 0, w, h, 15);
  g.endFill();
  g.tint = initialState ? COLOR_BUTTON_ACTIVE : COLOR_BUTTON_INACTIVE

  g.x = x
  g.y = y

  g.buttonMode = true
  g.interactive = true
  g.interactiveChildren = false
  g.buttonStates = new Set()
  g.buttonLastState = false

  // hacks to ensure reasonable multitouch behavior
  const f = e => {
    const release = e.type == 'pointerup' || e.type == 'pointerupoutside' || e.type =='pointercancel'
    const pressing = !release && app.renderer.plugins.interaction.hitTest(e.data.global, g) && e.data.buttons == 1
    const id = e.data.pointerId
    if (pressing) {
      g.buttonStates.add(id)
    } else {
      g.buttonStates.delete(id)
    }
    // console.log(text, pressing, g.buttonStates, e.type, id)
    const state = g.buttonStates.size != 0
    if (g.buttonLastState != state) {
      g.buttonLastState = state
      callback(state)
    } 
  }

  g.on('pointermove', f)
  g.on('pointerdown', f)
  g.on('pointerup', f)
  g.on('pointerupoutside', f)
  g.on('pointercancel', f)

  return g
}

function createMessages(width, height, margin) {
  let messagesContainer = new PIXI.Container()
  let messages = {}

  const ROW_HEIGHT = 30
  let x = margin
  let y = margin

  messages.iteration = new PIXI.Text(texts.iteration, TEXT_STYLE)
  messages.iteration.position.set(x, y)
  messagesContainer.addChild(messages.iteration)
  y += ROW_HEIGHT

  messages.funds = new PIXI.Text(texts.funds, TEXT_STYLE)
  messages.funds.position.set(x, y)
  messagesContainer.addChild(messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    messages.price = new PIXI.Text(texts.price, TEXT_STYLE)
    messages.price.position.set(x, y)
    messagesContainer.addChild(messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    let style = TEXT_STYLE.clone()
    style.align = 'left'
    style.fontSize = 20
    messages.debug = new PIXI.Text(texts.debug, style)
    messages.debug.position.set(x, y + ROW_HEIGHT)
    messagesContainer.addChild(messages.debug)
  }

  messages.summary = new MultiStyleText(texts.summary, TEXT_MULTI_STYLE)
  messages.summary.position.set(width / 2, height / 2 + margin)
  messages.summary.anchor.set(0.5, 0.0)
  messagesContainer.addChild(messages.summary)

  messages.highscores = new MultiStyleText(texts.highscores, TEXT_MULTI_STYLE)
  messages.highscores.position.set(width / 2, height / 2)
  messages.highscores.anchor.set(0.5, 0.5)
  messagesContainer.addChild(messages.highscores)

  return {messagesContainer, messages}
}

function createLogos(width, height, margin) {
  let logoContainer = new PIXI.Container()

  let logo = new PIXI.Sprite.from('logo_vertical.png')
  logo.position.set(width / 2, height / 2 - margin)
  logo.anchor.set(0.5, 1.0)
  logoContainer.addChild(logo)

  let createdBy = new PIXI.Sprite.from('created.png')
  createdBy.position.set(margin, height - margin)
  createdBy.anchor.set(0.0, 1.0)
  createdBy.scale.set(0.5)
  createdBy.interactive = true
  createdBy.buttonMode = true
  createdBy.on('click', () => { window.location.href = 'https://decent.org/' })
  createdBy.on('tap', () => { window.location.href = 'https://decent.org/' })
  logoContainer.addChild(createdBy)

  logoContainer.visible = isMainScreen()
  return logoContainer
}

function createSmallLogo(width, height, margin) {
  let logo = new PIXI.Sprite.from('logo_small.png')
  logo.position.set(width - margin, margin)
  logo.anchor.set(1.0, 0.0)
  logo.scale.set(0.5)
  logo.visible = !isMainScreen()
  return logo
}

function createGrid() {
  let grid = new PIXI.Container()

  const p0 = priceData.series[0]

  const gradHeight = 256
  const grad = gradientTexture(1, gradHeight)

  const bands = 20
  const alpha = 0.12

  let ppi = p0
  for (let i = 1; i <= bands; i++) {
    let prevY = Y_SCALE_FACTOR * priceData.scale * (ppi - p0)
    ppi *= 1.1
    let y = Y_SCALE_FACTOR * priceData.scale * (ppi - p0)
  
    var sprite = new PIXI.Sprite(grad)
    sprite.x = 0
    sprite.y = prevY
    sprite.anchor.set(0.5, 0.0)
    sprite.alpha = alpha - (i * alpha / bands)
    sprite.scale.set(GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX * 2, (y - prevY) / gradHeight)
    grid.addChild(sprite)
  }

  let pmi = p0
  for (let i = 1; i <= bands; i++) {
    let prevY = Y_SCALE_FACTOR * priceData.scale * (pmi - p0)
    pmi *= 0.9
    let y = Y_SCALE_FACTOR * priceData.scale * (pmi - p0)

    var sprite = new PIXI.Sprite(grad)
    sprite.x = 0
    sprite.y = y
    sprite.anchor.set(0.5, 0.0)
    sprite.alpha = alpha - (i * alpha / bands)
    sprite.scale.set(GAME_LENGTH_TICKS * GRAPH_X_GRANULARITY_PX * 2, (prevY - y) / gradHeight)
    grid.addChild(sprite)
  }

  let days = new PIXI.Graphics()
  const mul = 24 * GRAPH_X_GRANULARITY_PX
  for (let i = -GAME_LENGTH_DAYS; i <= GAME_LENGTH_DAYS; i++) {
    days.lineStyle(2, i < 0 ? 0x222222 : (i == 0 ? 0x444444 : 0x333333))
        .moveTo(i * mul, Y_SCALE_FACTOR * priceData.scale * (pmi - p0))
        .lineTo(i * mul, Y_SCALE_FACTOR * priceData.scale * (ppi - p0))
  }
  grid.addChild(days)

  return grid
}

function gradientTexture(w, h) {
  var canvas = document.createElement('canvas')
  canvas.width = w
  canvas.height = h
  var ctx = canvas.getContext('2d')
  var gradient = ctx.createLinearGradient(0, 0, 0, h)
  gradient.addColorStop(0, '#000000')
  gradient.addColorStop(1, '#ffffff')
  ctx.fillStyle = gradient
  ctx.fillRect(0, 0, w, h)
  return PIXI.Texture.fromCanvas(canvas)
}

function createPlayer() {
  let player = new PIXI.Graphics()
  player.alpha = 0.2
  player.lineStyle(4, 0xffffff)
  player.drawCircle(0, 0, 8)
  player.endFill()
  return player
}


// ===== trades =====

function enterTrade(isLong, i, margin) {
  assets.trade = {}
  assets.trade.barOpen = assets.trade.barClose = i
  assets.trade.isLong = isLong
  assets.trade.strikePrice = priceData.series[i]
  assets.trade.margin = margin
  assets.trade.current = margin
  assets.funds = assets.funds - margin
  assets.trades.push(assets.trade)
}

function exitTrade() {
  assets.funds = assets.funds + assets.trade.current
  assets.trade = null
}

function updateTrade(i, x, y) {
  if (!assets.trade) {
    return
  }
  assets.trade.barClose = i

  // TODO: interpolate estimated price between ticks
  const longValue = assets.trade.margin / assets.trade.strikePrice * priceData.series[i]
  if (assets.trade.isLong) {
    assets.trade.current = longValue
  } else {
    // assets.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // assets.margin / assets.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti assets.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    assets.trade.current = 2 * assets.trade.margin - longValue
  }

  const profit = Math.round(assets.trade.current - assets.trade.margin)

  // update label
  if (!assets.trade.label) {
    assets.trade.label = new PIXI.Text('', TEXT_STYLE)
    assets.trade.label.scale.set(1, -1)
    assets.trade.label.anchor.set(0.25, 0.5)
    entities.tradelabels.addChild(assets.trade.label)
  }
  assets.trade.label.position.set(x, assets.trade.isLong ? y + 20 : y - 25)
  assets.trade.label.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE
  assets.trade.label.text
    = (profit < 0 ? '-$' : '+$')
    + Math.abs(profit)
    + (assets.trade.isLong ? '\u25B3' : '\u25BD')

  // update trade line
  if (assets.trade.line) {
    entities.tradelines.removeChild(assets.trade.line)
  }

  const color = profit < 0 ? 0xff0000 : 0x00ff00
  assets.trade.line = new PIXI.Graphics()
  const a = assets.trade.barOpen
  assets.trade.line.lineStyle(5, color, 0.66)
    .moveTo(a * GRAPH_X_GRANULARITY_PX, Y_SCALE_FACTOR * priceData.scale * (priceData.series[a] - priceData.series[0]))
    .lineTo(x, y)
  entities.tradelines.addChild(assets.trade.line)
}


// ===== high scores =====

function saveResult(returns, hodl, trades) {
  var q = '?player=' + encodeURIComponent(player)
  q += '&return=' + encodeURIComponent(returns.toFixed(3))
  q += '&hodl=' + encodeURIComponent(hodl.toFixed(3))
  q += '&trades=' + encodeURIComponent(trades)
  q += '&start=' + encodeURIComponent(priceData.startTick)
  q += '&stop=' + encodeURIComponent(priceData.stopTick)
  var scr = document.createElement('script')
  scr.src = SHEET_URL + q
  document.body.appendChild(scr)
}

function callback(p) {
  var data = JSON.parse(p)
  if (gameOver && data.result == 'success') {
    data.top.forEach(entry => {
      addScore(false, entry[0], entry[1], entry[3])
    })
    showScores()
  }
}

function addScore(self, player, result, trades) {
  assets.scores.push({
    self: self,
    player: player,
    result: Math.round(result * 1000) / 1000,
    trades: trades
  })
}

function showScores() {
  let text = '<strong>RESULTS</strong>\nfor the same time period\n'
  assets.scores = uniqueSorted(assets.scores, (a, b) => b.result - a.result || a.player.localeCompare(b.player))
  assets.scores.forEach(e => {
    text += '\n'
      + tag(e.self ? 'self' : (e.player == HODL_NAME ? 'hodl' : 'b'),
        e.player.slice(0, 14).padEnd(14, ' ')
        + tag(e.result >= 0 ? 'profit' : 'loss', toPercent(e.result).padStart(8, ' '))
        + tag('tr', (' (' + toTrades(e.trades) + ')').padEnd(14, ' '))
      )
  })
  text += '\n\nPress [SPACE] to restart'
  texts.highscores = text
  updateTexts()
}


// ===== event listeners =====

window.onresize = function (event) {
  clearTimeout(arguments.callee.timerId)
  arguments.callee.timerId = setTimeout(function() {
    screenWidth = window.innerWidth
    screenHeight = window.innerHeight
    setupUI(screenWidth, screenHeight)
    if (isGameOverScreen()) {
      zoomOutFull()
    } else if (isMainScreen()) {
      setViewPort(0, 0, OFFSET_X)
    }
    app.renderer.resize(screenWidth, screenHeight)
    window.scrollTo(0, 0)
  }, 250)
}

const listenerBlur = event => {
  onNeutral()
  onWarp(false)
}

const listenerGlobalTap = event => {
  if (gameOver) {
    setup()
  } else if (!gameStarted) {
    startGame()
  }
}

const listenerKeyDown = event => {
  if (gameOver) {
    if (event.code === 'Space') {
      setup()
    }
    return
  }
  if (event.code === 'KeyS' || event.code === 'ArrowDown') {
    if (input.long) {
      onNeutral()
    } else {
      onShort()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'KeyL' || event.code === 'ArrowUp') {
    if (input.short) {
      onNeutral()
    } else {
      onLong()
    }
    if (!gameStarted) {
      startGame()
    }
  } else if (event.code === 'Space') {
    onNeutral()
    if (!gameStarted) {
      startGame()
    }
  }
  if (event.key === 'Shift') {
    onWarp(true)
  }
}

const listenerKeyUp = event => {
  if (event.key === 'Shift') {
    onWarp(false)
  }
}

function addInputListeners() {
  window.addEventListener('blur', listenerBlur, false)
  window.addEventListener('keydown', listenerKeyDown, false)
  window.addEventListener('keyup', listenerKeyUp, false)
}


// ===== utilities (stateless, pure functions) =====

function getQueryParam(param) {
  var query = window.location.search.substring(1)
  var vars = query.split('&')
  for (var i = 0; i < vars.length; i++) {
      var pair = vars[i].split('=')
      if (decodeURIComponent(pair[0]) == param) {
          return decodeURIComponent(pair[1])
      }
  }
  return null
}

function uniqueSorted(arr, cmp) {
  return arr.sort(cmp).filter((e, i, arr) => !i || cmp.apply(null, [e, arr[i - 1]]) != 0)
}

function tag(tag, string) {
  return (tag ? '<' + tag + '>' : '')
    + string
    + (tag ? '</' + tag + '>' : '')
}

function toPercent(num) {
  return (num * 100).toFixed(1) + '%'
}

function toAbsPercent(num) {
  return toPercent(Math.abs(num))
}

function toTrades(num) {
  return num === 0 ? 'no trades' :
    num === 1 ? '1 trade' :
    num + ' trades'
}

function parsePriceData(data, ticks) {
  const chunks = Math.floor(data.values.length / ticks)
  const fromIndex = ticks * (Math.floor(Math.random() * (chunks - 1)) + 1)
  const series = data.values.slice(fromIndex, fromIndex + ticks + 1)
  const pastSeries = data.values.slice(fromIndex - ticks, fromIndex + 1)
  const first = series[0]
  return {
    series: series,
    pastSeries: pastSeries,
    min: Math.min(...series),
    max: Math.max(...series),
    runningMin: first,
    runningMax: first,
    scale: 1 / (2 * (first * 1.1 * 1.1 - first * 0.9 * 0.9)),
    startTick: fromIndex,
    stopTick: fromIndex + ticks,
  }
}

function isMainScreen() {
  return !gameStarted && !gameOver
}

function isGameRunning() {
  return gameStarted && !gameOver
}

function isGameOverScreen() {
  return !gameStarted && gameOver
}

// ===== text styles =====

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 28,
  fill: 0xffffff,
  align: 'center',
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_MULTI_STYLE = {
  'default': {
    fontFamily: '"B612 Mono", monospace',
    fontSize: 20,
    fill: 0xcccccc,
    align: 'center',
    dropShadow: true,
    dropShadowAlpha: 0.6,
    dropShadowBlur: 10,
    dropShadowDistance: 3,
  },
  'b': {
    fontWeight: 'bold',
  },
  'strong': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'title': {
    fontSize: 28,
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'self': {
    fontWeight: 'bold',
    fill: 0xffff00,
  },
  'hodl': {
    fontWeight: 'bold',
    fill: 0xffffff,
  },
  'profit': {
    fontWeight: 'bold',
    fill: 0x00ff00,
  },
  'loss': {
    fontWeight: 'bold',
    fill: 0xff0000,
  },
  'tr': {
    fill: 0x666666,
  },
};

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: '"B612 Mono", monospace',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
  dropShadow: true,
  dropShadowAlpha: 0.6,
  dropShadowBlur: 10,
  dropShadowDistance: 3,
});

    </script>
  </body>
</html>
