<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Crypto Climber</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/4.8.2/pixi.min.js"></script>
    <style>* {padding: 0; margin: 0}</style>
  </head>
  <body>
    <script>

const INIT_FUNDS = 10000
const TICKS_PER_DAY = 24
const GAME_LENGTH_DAYS = 30
const GAME_LENGTH_TICKS = GAME_LENGTH_DAYS * TICKS_PER_DAY
const GRAPH_X_GRANULARITY_PX = 5 // smaller is more dense
const SPEED = 15 // smaller is faster
const ZOOM = 2
const SHOW_PRICE = false
const SHOW_DEBUG = false
const BASELINE_COLOR = 0x666666

const INTRO = 'Crypto Climber\n\n' +
  'You\'ll get a random ' + GAME_LENGTH_DAYS + ' day sample of Bitcoin\'s price history.' +
  '\nCan you trade it like a champ?' +
  '\n\nHold [L] if you think the price is going up to open a LONG position' +
  '\nHold [S] if you think the price is going down to SHORT SELL Bitcoin' +
  '\n\nPress [SPACE] to start!'

const CONF = {
  width: 1024,
  height: 768,
  antialias: true,
  transparent: false,
  resolution: 1
};

const app = new PIXI.Application(CONF);
const SCREEN_WIDTH = window.innerWidth
const SCREEN_HEIGHT = window.innerHeight

// Full screen
app.renderer.view.style.position = 'absolute';
app.renderer.view.style.display = 'block';
app.renderer.autoResize = true;
app.renderer.resize(SCREEN_WIDTH, SCREEN_HEIGHT);

document.body.appendChild(app.view);

PIXI.loader
  .add('bg', 'bg_tile.jpg')
  .add('prices', 'btc1h.json')
  .load(setup);

const TEXT_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 28,
  fill: 0xcccccc,
  align: 'center',
});

const TEXT_PROFIT_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0x00ff00,
});

const TEXT_LOSS_STYLE = new PIXI.TextStyle({
  fontFamily: 'Helvetica, sans-serif',
  fontSize: 20,
  fontWeight: 'bold',
  fill: 0xff0000,
});


function defaultEntities() {
  return {
    gamespace: null,
    messages: {
      iteration: null,
      funds: null,
      summary: null,
      price: null,
      debug: null,
    },
    baselines: null,
    lines: [],
    player: null,
  }
}
var ENTITIES = defaultEntities()

var ASSETS = {
  funds: INIT_FUNDS,
  trade: null,
  trades: [],
}

var priceData

function setup() {
  app.ticker.remove(update)
  app.stage.removeChildren()

  time = 0
  tick = -1

  ENTITIES = defaultEntities()
  ASSETS.funds = INIT_FUNDS
  priceData = parsePriceData(PIXI.loader.resources.prices.data)
  GAME_WIDTH = (priceData.series.length - 1) * GRAPH_X_GRANULARITY_PX
  GAME_HEIGHT = priceData.max - priceData.min

  app.stage.addChild(createBackground())

  ENTITIES.gamespace = new PIXI.Container()
  ENTITIES.gamespace.addChild(createBaseLines())
  ENTITIES.gamespace.addChild(createGraph())
  ENTITIES.gamespace.addChild(createPlayer())
  app.stage.addChild(ENTITIES.gamespace)

  app.stage.addChild(createMessages())

  setViewPort(0,0)
  addInputListeners()
  app.ticker.add(update)
}

function createBackground() {
  background = new PIXI.Container()
  const bgTexture = PIXI.loader.resources.bg.texture
  const w = bgTexture.width
  const h = bgTexture.height
  for (let i = -w; i < SCREEN_WIDTH; i += w) {
    for (let j = -h; j < SCREEN_HEIGHT; j += h) {
      let bgSprite = new PIXI.Sprite(bgTexture)
      bgSprite.position.set(i, j)
      bgSprite.alpha = 0.5
      background.addChild(bgSprite)
    }
  }
  return background
}

function createMessages() {
  messagesContainer = new PIXI.Container()

  var x = 4
  var y = 4
  const ROW_HEIGHT = 30
  ENTITIES.messages.iteration = new PIXI.Text('Day 0 of ' + GAME_LENGTH_DAYS, TEXT_STYLE)
  ENTITIES.messages.iteration.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.iteration)
  y += ROW_HEIGHT

  ENTITIES.messages.funds = new PIXI.Text('Equity $' + ASSETS.funds, TEXT_STYLE)
  ENTITIES.messages.funds.position.set(x, y)
  messagesContainer.addChild(ENTITIES.messages.funds)
  y += ROW_HEIGHT

  if (SHOW_PRICE) {
    ENTITIES.messages.price = new PIXI.Text('price: $', TEXT_STYLE)
    ENTITIES.messages.price.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.price)
    y += ROW_HEIGHT
  }

  if (SHOW_DEBUG) {
    ENTITIES.messages.debug = new PIXI.Text('', TEXT_STYLE)
    ENTITIES.messages.debug.position.set(x, y)
    messagesContainer.addChild(ENTITIES.messages.debug)
    y += ROW_HEIGHT
  }

  ENTITIES.messages.summary = new PIXI.Text(INTRO, TEXT_STYLE)
  ENTITIES.messages.summary.position.set(SCREEN_WIDTH/2, 64)
  ENTITIES.messages.summary.anchor.set(0.5, 0)
  messagesContainer.addChild(ENTITIES.messages.summary)

  return messagesContainer
}

function createBaseLines() {
  p0 = priceData.series[0]

  const margin = SCREEN_WIDTH * ZOOM
  let baselines = new PIXI.Container()
  let baseline = new PIXI.Graphics()
  baseline.lineStyle(1, BASELINE_COLOR)
    .moveTo(-margin, 0)
    .lineTo(GAME_WIDTH + margin, 0)
  baselines.addChild(baseline)

  let ppi = p0
  //for (i = 1; ppi < priceData.max; i++) {
  for (i = 1; i <= 20; i++) {
    ppi *= 1.1
    let line = new PIXI.Graphics()
    let y = priceData.scale * (ppi - p0)
    line.lineStyle(1, BASELINE_COLOR)
      .moveTo(-margin, y)
      .lineTo(GAME_WIDTH + margin, y)
    baselines.addChild(line)
  }

  let pmi = p0
  //for (i = 1; pmi > priceData.min; i++) {
  for (i = 1; i <= 20; i++) {
    pmi *= 0.9
    let baselineMinus = new PIXI.Graphics()
    let y = priceData.scale * (pmi - p0)
    baselineMinus.lineStyle(1, BASELINE_COLOR)
      .moveTo(-margin, y)
      .lineTo(GAME_WIDTH + margin, y)
    baselines.addChild(baselineMinus)
  }

  ENTITIES.baselines = baselines
  return baselines
}

function createPlayer() {
  ENTITIES.player = new PIXI.Graphics()
  ENTITIES.player.alpha = 0.5
  ENTITIES.player.lineStyle(3, 0xffffff)
  ENTITIES.player.drawCircle(0, 0, 8)
  ENTITIES.player.endFill()
  return ENTITIES.player
}

function createGraph() {
  p0 = priceData.series[0]
  graph = new PIXI.Container()
  for (i = 0; i < priceData.series.length - 1; i++) {
    line = new PIXI.Graphics()
    line.position.set(0, 0)
    line.lineStyle(1, 0xffffff)
        .moveTo(GRAPH_X_GRANULARITY_PX * i, priceData.scale * (priceData.series[i] - p0))
        .lineTo(GRAPH_X_GRANULARITY_PX * (i + 1), priceData.scale * (priceData.series[i + 1] - p0))
    line.visible = false
    ENTITIES.lines.push(line)
    graph.addChild(line)
  }
  return graph
}

function setViewPort(x, y) {
  ENTITIES.gamespace.scale.x = ZOOM
  ENTITIES.gamespace.scale.y = -ZOOM
  ENTITIES.gamespace.position.x = -(x * ZOOM - SCREEN_WIDTH / 2)
  ENTITIES.gamespace.position.y = -(-y * ZOOM - SCREEN_HEIGHT / 2)
}

function movePlayer(x, y) {
  ENTITIES.player.x = x
  ENTITIES.player.y = y
}

var time = 0
var tick = -1

var gameOver = false
var gameStarted = false

const INPUT = {
  short: false,
  long: false,
}

function positionToColor() {
  if (ASSETS.trade) {
    if (ASSETS.trade.isLong) {
      return 0x00aaaa
    } else {
      return 0xaaaa00
    }
  } else {
    return 0xffffff
  }
}

function positionToThickness() {
  return ASSETS.trade ? 4 : 1
}

function update(dt) {
  if (!gameStarted) {
    return
  }

  time += dt / SPEED
  var i = Math.floor(time)
  if (i >= GAME_LENGTH_TICKS) {
    if (!gameOver) {
      gameOver = true
      showGameOver(i)
    }
    return
  }


  x = time * GRAPH_X_GRANULARITY_PX
  y = priceData.scale * ((priceData.series[tick] - priceData.series[0])
    + (time - tick) * (priceData.series[tick + 1] - priceData.series[tick]))
  setViewPort(x, y)
  movePlayer(x, y)
  updateTrade(i)

  if (i > tick) {
    tick = i

    const currentPrice = priceData.series[i]
    priceData.runningMin = Math.min(priceData.runningMin, currentPrice)
    priceData.runningMax = Math.max(priceData.runningMax, currentPrice)

    handleInput(i)

    ENTITIES.lines[i].visible = true
    // if (ASSETS.trade) {
    //   ENTITIES.lines[i].tint = positionToColor()
    // }

    updatePlayer()
    updateMessages(i)
  }


}

function handleInput(i) {
  if (INPUT.long && !INPUT.short) {
    // LONG
    if (ASSETS.trade) {
      if (ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(true, i, ASSETS.funds)
  } else if (!INPUT.long && INPUT.short) {
    // SHORT
    if (ASSETS.trade) {
      if (!ASSETS.trade.isLong) {
        return
      } else {
        exitTrade()
      }
    }
    enterTrade(false, i, ASSETS.funds)
  } else {
    // NEUTRAL
    if (ASSETS.trade) {
      exitTrade()
    }
  }
}

function updatePlayer() {
  ENTITIES.player.tint = positionToColor()
}

function updateMessages(i) {
  ENTITIES.messages.summary.text = ''

  ENTITIES.messages.iteration.text = 'Day ' + Math.floor(i / TICKS_PER_DAY) + ' of ' + GAME_LENGTH_DAYS
  var equity = ASSETS.funds + (ASSETS.trade ? ASSETS.trade.current : 0)

  ENTITIES.messages.funds.text = 'Equity $' + Math.round(equity)
  if (SHOW_PRICE) {
    ENTITIES.messages.price.text = 'price: $' + Math.round(priceData.series[i])
  }
  if (SHOW_DEBUG) {
    ENTITIES.messages.debug.text =
      'inputs: ' + (INPUT.short?'S':' ') + (INPUT.long?'L':' ') +
      ' trade: ' + (ASSETS.trade ? (ASSETS.trade.isLong ? 'L' : 'S') : '-')
  }
}

function showGameOver(i) {
  if (ASSETS.trade) {
    exitTrade()
  }
  updateMessages(i)

  const result = ASSETS.funds - INIT_FUNDS
  const resultPercent = (result / INIT_FUNDS * 100).toFixed(1)
  const hodlPercent = ((priceData.series[i] / priceData.series[0] - 1) * 100).toFixed(1)
  var summary = result >= 0 ?
      ('YAY! You made a ' + resultPercent + '% return') :
      ('ONOES! You lost ' + Math.abs(resultPercent) + '% of your capital')
  summary += '\nwith ' + ASSETS.trades.length + ' trades.'
  summary += '\n\nHODLer return ' + hodlPercent + '%'
  // summary += '\nPeriod: ' + priceData.from + ' - ' + priceData.to
  // summary += '\nPrice range: $' + priceData.min + ' - $' + priceData.max
  summary += '\n\nPress [SPACE] to reset.'
  ENTITIES.messages.summary.text = summary
}

function enterTrade(isLong, i, margin) {
  ASSETS.trade = {}
  ASSETS.trade.barOpen = ASSETS.trade.barClose = i
  ASSETS.trade.isLong = isLong
  ASSETS.trade.strikePrice = priceData.series[i]
  ASSETS.trade.margin = margin
  ASSETS.trade.current = margin
  ASSETS.funds = ASSETS.funds - margin
  ASSETS.trades.push(ASSETS.trade)
}

function exitTrade() {
  ASSETS.funds = ASSETS.funds + ASSETS.trade.current
  ASSETS.trade = null
}

function updateTrade(i) {
  if (!ASSETS.trade) {
    return
  }
  ASSETS.trade.barClose = i

  // TODO: interpolate estimated price between ticks
  const longValue = ASSETS.trade.margin / ASSETS.trade.strikePrice * priceData.series[i]
  if (ASSETS.trade.isLong) {
    ASSETS.trade.current = longValue
  } else {
    // ASSETS.margin dolcsi ertekben kolcsonkertem bitcoint, es rogton eladtam
    // ennyi bitcoint adtam el eredetileg:
    // ASSETS.margin / ASSETS.strikePrice
    // === ennyit kell visszaadjak ma
    // nekem meg megvan az eredeti ASSETS.margin dolcsim
    // abbol megveszem a bitcoint mai aron, es a kulonbozetet megnyertem!
    // bwahahaha
    ASSETS.trade.current = 2 * ASSETS.trade.margin - longValue
  }

  const profit = Math.round(ASSETS.trade.current - ASSETS.trade.margin)

  // update label
  if (!ASSETS.trade.label) {
    ASSETS.trade.label = new PIXI.Text('', TEXT_STYLE)
    ASSETS.trade.label.scale.set(1 / ZOOM, -1 / ZOOM)
    ENTITIES.gamespace.addChild(ASSETS.trade.label)
  }
  ASSETS.trade.label.position.set(x - 15, y + (ASSETS.trade.isLong ? -10 : 20))

  ASSETS.trade.label.text = (profit < 0 ? ' -$' : ' +$') + Math.abs(profit)
  ASSETS.trade.label.style = profit < 0 ? TEXT_LOSS_STYLE : TEXT_PROFIT_STYLE

  // update trade line
  if (ASSETS.trade.line) {
    ENTITIES.gamespace.removeChild(ASSETS.trade.line)
  }

  const color = profit < 0 ? 0xff0000 : 0x00ff00
  ASSETS.trade.line = new PIXI.Graphics()
  const a = ASSETS.trade.barOpen
  ASSETS.trade.line.lineStyle(3, color)
    .moveTo(a * GRAPH_X_GRANULARITY_PX, priceData.scale * (priceData.series[a] - priceData.series[0]))
    .lineTo(x, y)
  ENTITIES.gamespace.addChild(ASSETS.trade.line)

}

function parsePriceData(data) {
  const fromIndex = Math.floor(Math.random() * (data.values.length - GAME_LENGTH_TICKS - 1))
  const series = data.values.slice(fromIndex, fromIndex + GAME_LENGTH_TICKS + 1)
  const first = series[0]
  const min = Math.min(...series)
  const max = Math.max(...series)
  return {
    series: series,
    min: min,
    max: max,
    runningMin: first,
    runningMax: first,
    scale: SCREEN_HEIGHT / 2 / (first * 1.1 * 1.1 - first * 0.9 * 0.9),
  }
}

function addInputListeners() {
  window.addEventListener('keydown', event => {
    if (!gameStarted && event.key === ' ') {
      gameStarted = true
      ENTITIES.messages.summary.text = ''
      return
    }
    if (event.key === 's') {
      INPUT.short = true
    } else if (event.key === 'l') {
      INPUT.long = true
    } else if (gameOver && event.key === ' ') {
      gameOver = false
      gameStarted = false
      setup()
    }
  }, false)
  window.addEventListener('keyup', event => {
    if (event.key === 's') {
      INPUT.short = false
    }
    if (event.key === 'l') {
      INPUT.long = false
    }
  }, false)
}

    </script>
  </body>
</html>
